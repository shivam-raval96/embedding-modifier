{"ast":null,"code":"/**\n * Based on aframe/examples/showcase/tracked-controls.\n *\n * Implement bounding sphere collision detection for entities with a mesh.\n * Sets the specified state on the intersected entities.\n *\n * @property {string} objects - Selector of the entities to test for collision.\n * @property {string} state - State to set on collided entities.\n *\n */\nmodule.exports = AFRAME.registerComponent('sphere-collider', {\n  schema: {\n    objects: {\n      default: ''\n    },\n    state: {\n      default: 'collided'\n    },\n    radius: {\n      default: 0.05\n    },\n    watch: {\n      default: true\n    }\n  },\n  init: function init() {\n    /** @type {MutationObserver} */\n    this.observer = null;\n    /** @type {Array<Element>} Elements to watch for collisions. */\n    this.els = [];\n    /** @type {Array<Element>} Elements currently in collision state. */\n    this.collisions = [];\n    this.handleHit = this.handleHit.bind(this);\n    this.handleHitEnd = this.handleHitEnd.bind(this);\n  },\n  remove: function remove() {\n    this.pause();\n  },\n  play: function play() {\n    var sceneEl = this.el.sceneEl;\n    if (this.data.watch) {\n      this.observer = new MutationObserver(this.update.bind(this, null));\n      this.observer.observe(sceneEl, {\n        childList: true,\n        subtree: true\n      });\n    }\n  },\n  pause: function pause() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  },\n  /**\n   * Update list of entities to test for collision.\n   */\n  update: function update() {\n    var data = this.data;\n    var objectEls;\n\n    // Push entities into list of els to intersect.\n    if (data.objects) {\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\n    } else {\n      // If objects not defined, intersect with everything.\n      objectEls = this.el.sceneEl.children;\n    }\n    // Convert from NodeList to Array\n    this.els = Array.prototype.slice.call(objectEls);\n  },\n  tick: function () {\n    var position = new THREE.Vector3(),\n      meshPosition = new THREE.Vector3(),\n      colliderScale = new THREE.Vector3(),\n      size = new THREE.Vector3(),\n      box = new THREE.Box3(),\n      distanceMap = new Map();\n    return function () {\n      var el = this.el,\n        data = this.data,\n        mesh = el.getObject3D('mesh'),\n        collisions = [];\n      var colliderRadius;\n      if (!mesh) {\n        return;\n      }\n      distanceMap.clear();\n      el.object3D.getWorldPosition(position);\n      el.object3D.getWorldScale(colliderScale);\n      colliderRadius = data.radius * scaleFactor(colliderScale);\n      // Update collision list.\n      this.els.forEach(intersect);\n\n      // Emit events and add collision states, in order of distance.\n      collisions.sort(function (a, b) {\n        return distanceMap.get(a) > distanceMap.get(b) ? 1 : -1;\n      }).forEach(this.handleHit);\n\n      // Remove collision state from current element.\n      if (collisions.length === 0) {\n        el.emit('hit', {\n          el: null\n        });\n      }\n\n      // Remove collision state from other elements.\n      this.collisions.filter(function (el) {\n        return !distanceMap.has(el);\n      }).forEach(this.handleHitEnd);\n\n      // Store new collisions\n      this.collisions = collisions;\n\n      // Bounding sphere collision detection\n      function intersect(el) {\n        var radius, mesh, distance, extent;\n        if (!el.isEntity) {\n          return;\n        }\n        mesh = el.getObject3D('mesh');\n        if (!mesh) {\n          return;\n        }\n        box.setFromObject(mesh).getSize(size);\n        extent = Math.max(size.x, size.y, size.z) / 2;\n        radius = Math.sqrt(2 * extent * extent);\n        box.getCenter(meshPosition);\n        if (!radius) {\n          return;\n        }\n        distance = position.distanceTo(meshPosition);\n        if (distance < radius + colliderRadius) {\n          collisions.push(el);\n          distanceMap.set(el, distance);\n        }\n      }\n      // use max of scale factors to maintain bounding sphere collision\n      function scaleFactor(scaleVec) {\n        return Math.max.apply(null, scaleVec.toArray());\n      }\n    };\n  }(),\n  handleHit: function handleHit(targetEl) {\n    targetEl.emit('hit');\n    targetEl.addState(this.data.state);\n    this.el.emit('hit', {\n      el: targetEl\n    });\n  },\n  handleHitEnd: function handleHitEnd(targetEl) {\n    targetEl.emit('hitend');\n    targetEl.removeState(this.data.state);\n    this.el.emit('hitend', {\n      el: targetEl\n    });\n  }\n});","map":{"version":3,"names":["module","exports","AFRAME","registerComponent","schema","objects","default","state","radius","watch","init","observer","els","collisions","handleHit","bind","handleHitEnd","remove","pause","play","sceneEl","el","data","MutationObserver","update","observe","childList","subtree","disconnect","objectEls","querySelectorAll","children","Array","prototype","slice","call","tick","position","THREE","Vector3","meshPosition","colliderScale","size","box","Box3","distanceMap","Map","mesh","getObject3D","colliderRadius","clear","object3D","getWorldPosition","getWorldScale","scaleFactor","forEach","intersect","sort","a","b","get","length","emit","filter","has","distance","extent","isEntity","setFromObject","getSize","Math","max","x","y","z","sqrt","getCenter","distanceTo","push","set","scaleVec","apply","toArray","targetEl","addState","removeState"],"sources":["/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/aframe-extras/src/misc/sphere-collider.js"],"sourcesContent":["/**\n * Based on aframe/examples/showcase/tracked-controls.\n *\n * Implement bounding sphere collision detection for entities with a mesh.\n * Sets the specified state on the intersected entities.\n *\n * @property {string} objects - Selector of the entities to test for collision.\n * @property {string} state - State to set on collided entities.\n *\n */\nmodule.exports = AFRAME.registerComponent('sphere-collider', {\n  schema: {\n    objects: {default: ''},\n    state: {default: 'collided'},\n    radius: {default: 0.05},\n    watch: {default: true}\n  },\n\n  init: function () {\n    /** @type {MutationObserver} */\n    this.observer = null;\n    /** @type {Array<Element>} Elements to watch for collisions. */\n    this.els = [];\n    /** @type {Array<Element>} Elements currently in collision state. */\n    this.collisions = [];\n\n    this.handleHit = this.handleHit.bind(this);\n    this.handleHitEnd = this.handleHitEnd.bind(this);\n  },\n\n  remove: function () {\n    this.pause();\n  },\n\n  play: function () {\n    const sceneEl = this.el.sceneEl;\n\n    if (this.data.watch) {\n      this.observer = new MutationObserver(this.update.bind(this, null));\n      this.observer.observe(sceneEl, {childList: true, subtree: true});\n    }\n  },\n\n  pause: function () {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  },\n\n  /**\n   * Update list of entities to test for collision.\n   */\n  update: function () {\n    const data = this.data;\n    let objectEls;\n\n    // Push entities into list of els to intersect.\n    if (data.objects) {\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\n    } else {\n      // If objects not defined, intersect with everything.\n      objectEls = this.el.sceneEl.children;\n    }\n    // Convert from NodeList to Array\n    this.els = Array.prototype.slice.call(objectEls);\n  },\n\n  tick: (function () {\n    const position = new THREE.Vector3(),\n        meshPosition = new THREE.Vector3(),\n        colliderScale = new THREE.Vector3(),\n        size = new THREE.Vector3(),\n        box = new THREE.Box3(),\n        distanceMap = new Map();\n    return function () {\n      const el = this.el,\n          data = this.data,\n          mesh = el.getObject3D('mesh'),\n          collisions = [];\n      let colliderRadius;\n\n      if (!mesh) { return; }\n\n      distanceMap.clear();\n      el.object3D.getWorldPosition(position);\n      el.object3D.getWorldScale(colliderScale);\n      colliderRadius = data.radius * scaleFactor(colliderScale);\n      // Update collision list.\n      this.els.forEach(intersect);\n\n      // Emit events and add collision states, in order of distance.\n      collisions\n        .sort((a, b) => distanceMap.get(a) > distanceMap.get(b) ? 1 : -1)\n        .forEach(this.handleHit);\n\n      // Remove collision state from current element.\n      if (collisions.length === 0) { el.emit('hit', {el: null}); }\n\n      // Remove collision state from other elements.\n      this.collisions\n        .filter((el) => !distanceMap.has(el))\n        .forEach(this.handleHitEnd);\n\n      // Store new collisions\n      this.collisions = collisions;\n\n      // Bounding sphere collision detection\n      function intersect (el) {\n        let radius, mesh, distance, extent;\n\n        if (!el.isEntity) { return; }\n\n        mesh = el.getObject3D('mesh');\n\n        if (!mesh) { return; }\n\n        box.setFromObject(mesh).getSize(size);\n        extent = Math.max(size.x, size.y, size.z) / 2;\n        radius = Math.sqrt(2 * extent * extent);\n        box.getCenter(meshPosition);\n\n        if (!radius) { return; }\n\n        distance = position.distanceTo(meshPosition);\n        if (distance < radius + colliderRadius) {\n          collisions.push(el);\n          distanceMap.set(el, distance);\n        }\n      }\n      // use max of scale factors to maintain bounding sphere collision\n      function scaleFactor (scaleVec) {\n        return Math.max.apply(null, scaleVec.toArray());\n      }\n    };\n  })(),\n\n  handleHit: function (targetEl) {\n    targetEl.emit('hit');\n    targetEl.addState(this.data.state);\n    this.el.emit('hit', {el: targetEl});\n  },\n  handleHitEnd: function (targetEl) {\n    targetEl.emit('hitend');\n    targetEl.removeState(this.data.state);\n    this.el.emit('hitend', {el: targetEl});\n  }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}