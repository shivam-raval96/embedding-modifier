{"ast":null,"code":"/**\n * nav-mesh\n *\n * Waits for a mesh to be loaded on the current entity, then sets it as the\n * nav mesh in the pathfinding system.\n */\nmodule.exports = AFRAME.registerComponent('nav-mesh', {\n  init: function () {\n    this.system = this.el.sceneEl.systems.nav;\n    this.hasLoadedNavMesh = false;\n    this.el.addEventListener('object3dset', this.loadNavMesh.bind(this));\n  },\n  play: function () {\n    if (!this.hasLoadedNavMesh) this.loadNavMesh();\n  },\n  loadNavMesh: function () {\n    const object = this.el.getObject3D('mesh');\n    const scene = this.el.sceneEl.object3D;\n    if (!object) return;\n    let navMesh;\n    object.traverse(node => {\n      if (node.isMesh) navMesh = node;\n    });\n    if (!navMesh) return;\n    const navMeshGeometry = navMesh.geometry.isBufferGeometry ? new THREE.Geometry().fromBufferGeometry(navMesh.geometry) : navMesh.geometry.clone();\n    scene.updateMatrixWorld();\n    navMeshGeometry.applyMatrix(navMesh.matrixWorld);\n    this.system.setNavMeshGeometry(navMeshGeometry);\n    this.hasLoadedNavMesh = true;\n  }\n});","map":{"version":3,"names":["module","exports","AFRAME","registerComponent","init","system","el","sceneEl","systems","nav","hasLoadedNavMesh","addEventListener","loadNavMesh","bind","play","object","getObject3D","scene","object3D","navMesh","traverse","node","isMesh","navMeshGeometry","geometry","isBufferGeometry","THREE","Geometry","fromBufferGeometry","clone","updateMatrixWorld","applyMatrix","matrixWorld","setNavMeshGeometry"],"sources":["/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/aframe-extras/src/pathfinding/nav-mesh.js"],"sourcesContent":["/**\n * nav-mesh\n *\n * Waits for a mesh to be loaded on the current entity, then sets it as the\n * nav mesh in the pathfinding system.\n */\nmodule.exports = AFRAME.registerComponent('nav-mesh', {\n  init: function () {\n    this.system = this.el.sceneEl.systems.nav;\n    this.hasLoadedNavMesh = false;\n    this.el.addEventListener('object3dset', this.loadNavMesh.bind(this));\n  },\n\n  play: function () {\n    if (!this.hasLoadedNavMesh) this.loadNavMesh();\n  },\n\n  loadNavMesh: function () {\n    const object = this.el.getObject3D('mesh');\n    const scene = this.el.sceneEl.object3D;\n\n    if (!object) return;\n\n    let navMesh;\n    object.traverse((node) => {\n      if (node.isMesh) navMesh = node;\n    });\n\n    if (!navMesh) return;\n\n    const navMeshGeometry = navMesh.geometry.isBufferGeometry\n      ? new THREE.Geometry().fromBufferGeometry(navMesh.geometry)\n      : navMesh.geometry.clone();\n\n    scene.updateMatrixWorld();\n    navMeshGeometry.applyMatrix(navMesh.matrixWorld);\n    this.system.setNavMeshGeometry(navMeshGeometry);\n\n    this.hasLoadedNavMesh = true;\n  }\n});\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,OAAO,GAAGC,MAAM,CAACC,iBAAiB,CAAC,UAAU,EAAE;EACpDC,IAAI,EAAE,SAAAA,CAAA,EAAY;IAChB,IAAI,CAACC,MAAM,GAAG,IAAI,CAACC,EAAE,CAACC,OAAO,CAACC,OAAO,CAACC,GAAG;IACzC,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACJ,EAAE,CAACK,gBAAgB,CAAC,aAAa,EAAE,IAAI,CAACC,WAAW,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;EACtE,CAAC;EAEDC,IAAI,EAAE,SAAAA,CAAA,EAAY;IAChB,IAAI,CAAC,IAAI,CAACJ,gBAAgB,EAAE,IAAI,CAACE,WAAW,CAAC,CAAC;EAChD,CAAC;EAEDA,WAAW,EAAE,SAAAA,CAAA,EAAY;IACvB,MAAMG,MAAM,GAAG,IAAI,CAACT,EAAE,CAACU,WAAW,CAAC,MAAM,CAAC;IAC1C,MAAMC,KAAK,GAAG,IAAI,CAACX,EAAE,CAACC,OAAO,CAACW,QAAQ;IAEtC,IAAI,CAACH,MAAM,EAAE;IAEb,IAAII,OAAO;IACXJ,MAAM,CAACK,QAAQ,CAAEC,IAAI,IAAK;MACxB,IAAIA,IAAI,CAACC,MAAM,EAAEH,OAAO,GAAGE,IAAI;IACjC,CAAC,CAAC;IAEF,IAAI,CAACF,OAAO,EAAE;IAEd,MAAMI,eAAe,GAAGJ,OAAO,CAACK,QAAQ,CAACC,gBAAgB,GACrD,IAAIC,KAAK,CAACC,QAAQ,CAAC,CAAC,CAACC,kBAAkB,CAACT,OAAO,CAACK,QAAQ,CAAC,GACzDL,OAAO,CAACK,QAAQ,CAACK,KAAK,CAAC,CAAC;IAE5BZ,KAAK,CAACa,iBAAiB,CAAC,CAAC;IACzBP,eAAe,CAACQ,WAAW,CAACZ,OAAO,CAACa,WAAW,CAAC;IAChD,IAAI,CAAC3B,MAAM,CAAC4B,kBAAkB,CAACV,eAAe,CAAC;IAE/C,IAAI,CAACb,gBAAgB,GAAG,IAAI;EAC9B;AACF,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}