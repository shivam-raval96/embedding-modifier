{"ast":null,"code":"var e = function e() {};\ne.computeCentroids = function (e) {\n  var t, n, r;\n  for (t = 0, n = e.faces.length; t < n; t++) (r = e.faces[t]).centroid = new THREE.Vector3(0, 0, 0), r.centroid.add(e.vertices[r.a]), r.centroid.add(e.vertices[r.b]), r.centroid.add(e.vertices[r.c]), r.centroid.divideScalar(3);\n}, e.roundNumber = function (e, t) {\n  return Number(e.toFixed(t));\n}, e.sample = function (e) {\n  return e[Math.floor(Math.random() * e.length)];\n}, e.mergeVertexIds = function (e, t) {\n  var n = [];\n  if (e.forEach(function (e) {\n    t.indexOf(e) >= 0 && n.push(e);\n  }), n.length < 2) return [];\n  n.includes(e[0]) && n.includes(e[e.length - 1]) && e.push(e.shift()), n.includes(t[0]) && n.includes(t[t.length - 1]) && t.push(t.shift()), n = [], e.forEach(function (e) {\n    t.includes(e) && n.push(e);\n  });\n  for (var r = n[1], o = n[0], i = e.slice(); i[0] !== r;) i.push(i.shift());\n  for (var s = 0, u = t.slice(); u[0] !== o;) if (u.push(u.shift()), s++ > 10) throw new Error(\"Unexpected state\");\n  return u.shift(), u.pop(), i = i.concat(u);\n}, e.setPolygonCentroid = function (e, t) {\n  var n = new THREE.Vector3(),\n    r = t.vertices;\n  e.vertexIds.forEach(function (e) {\n    n.add(r[e]);\n  }), n.divideScalar(e.vertexIds.length), e.centroid.copy(n);\n}, e.cleanPolygon = function (e, t) {\n  for (var n = [], r = t.vertices, o = 0; o < e.vertexIds.length; o++) {\n    var i,\n      s,\n      u,\n      c = r[e.vertexIds[o]];\n    0 === o ? (i = e.vertexIds[1], s = e.vertexIds[e.vertexIds.length - 1]) : o === e.vertexIds.length - 1 ? (i = e.vertexIds[0], s = e.vertexIds[e.vertexIds.length - 2]) : (i = e.vertexIds[o + 1], s = e.vertexIds[o - 1]), u = r[s];\n    var h = r[i].clone().sub(c),\n      a = u.clone().sub(c),\n      d = h.angleTo(a);\n    if (d > Math.PI - .01 && d < Math.PI + .01) {\n      var f = [];\n      e.neighbours.forEach(function (t) {\n        t.vertexIds.includes(e.vertexIds[o]) || f.push(t);\n      }), e.neighbours = f;\n    } else n.push(e.vertexIds[o]);\n  }\n  e.vertexIds = n, this.setPolygonCentroid(e, t);\n}, e.isConvex = function (e, t) {\n  var n = t.vertices;\n  if (e.vertexIds.length < 3) return !1;\n  for (var r = !0, o = [], i = 0; i < e.vertexIds.length; i++) {\n    var s,\n      u,\n      c = n[e.vertexIds[i]];\n    0 === i ? (s = n[e.vertexIds[1]], u = n[e.vertexIds[e.vertexIds.length - 1]]) : i === e.vertexIds.length - 1 ? (s = n[e.vertexIds[0]], u = n[e.vertexIds[e.vertexIds.length - 2]]) : (s = n[e.vertexIds[i + 1]], u = n[e.vertexIds[i - 1]]);\n    var h = s.clone().sub(c),\n      a = u.clone().sub(c),\n      d = h.angleTo(a);\n    if (d === Math.PI || 0 === d) return !1;\n    var f = h.cross(a).y;\n    o.push(f);\n  }\n  return o.forEach(function (e) {\n    0 === e && (r = !1);\n  }), o.forEach(o[0] > 0 ? function (e) {\n    e < 0 && (r = !1);\n  } : function (e) {\n    e > 0 && (r = !1);\n  }), r;\n}, e.distanceToSquared = function (e, t) {\n  var n = e.x - t.x,\n    r = e.y - t.y,\n    o = e.z - t.z;\n  return n * n + r * r + o * o;\n}, e.isPointInPoly = function (e, t) {\n  for (var n = !1, r = -1, o = e.length, i = o - 1; ++r < o; i = r) (e[r].z <= t.z && t.z < e[i].z || e[i].z <= t.z && t.z < e[r].z) && t.x < (e[i].x - e[r].x) * (t.z - e[r].z) / (e[i].z - e[r].z) + e[r].x && (n = !n);\n  return n;\n}, e.isVectorInPolygon = function (e, t, n) {\n  var r = 1e5,\n    o = -1e5,\n    i = [];\n  return t.vertexIds.forEach(function (e) {\n    r = Math.min(n[e].y, r), o = Math.max(n[e].y, o), i.push(n[e]);\n  }), !!(e.y < o + .5 && e.y > r - .5 && this.isPointInPoly(i, e));\n}, e.triarea2 = function (e, t, n) {\n  return (n.x - e.x) * (t.z - e.z) - (t.x - e.x) * (n.z - e.z);\n}, e.vequal = function (e, t) {\n  return this.distanceToSquared(e, t) < 1e-5;\n};\nvar t = function t(e) {\n  this.content = [], this.scoreFunction = e;\n};\nt.prototype.push = function (e) {\n  this.content.push(e), this.sinkDown(this.content.length - 1);\n}, t.prototype.pop = function () {\n  var e = this.content[0],\n    t = this.content.pop();\n  return this.content.length > 0 && (this.content[0] = t, this.bubbleUp(0)), e;\n}, t.prototype.remove = function (e) {\n  var t = this.content.indexOf(e),\n    n = this.content.pop();\n  t !== this.content.length - 1 && (this.content[t] = n, this.scoreFunction(n) < this.scoreFunction(e) ? this.sinkDown(t) : this.bubbleUp(t));\n}, t.prototype.size = function () {\n  return this.content.length;\n}, t.prototype.rescoreElement = function (e) {\n  this.sinkDown(this.content.indexOf(e));\n}, t.prototype.sinkDown = function (e) {\n  for (var t = this.content[e]; e > 0;) {\n    var n = (e + 1 >> 1) - 1,\n      r = this.content[n];\n    if (!(this.scoreFunction(t) < this.scoreFunction(r))) break;\n    this.content[n] = t, this.content[e] = r, e = n;\n  }\n}, t.prototype.bubbleUp = function (e) {\n  for (var t = this.content.length, n = this.content[e], r = this.scoreFunction(n);;) {\n    var o = e + 1 << 1,\n      i = o - 1,\n      s = null,\n      u = void 0;\n    if (i < t) (u = this.scoreFunction(this.content[i])) < r && (s = i);\n    if (o < t) this.scoreFunction(this.content[o]) < (null === s ? r : u) && (s = o);\n    if (null === s) break;\n    this.content[e] = this.content[s], this.content[s] = n, e = s;\n  }\n};\nvar n = function n() {};\nn.init = function (e) {\n  for (var t = 0; t < e.length; t++) {\n    var n = e[t];\n    n.f = 0, n.g = 0, n.h = 0, n.cost = 1, n.visited = !1, n.closed = !1, n.parent = null;\n  }\n}, n.cleanUp = function (e) {\n  for (var t = 0; t < e.length; t++) {\n    var n = e[t];\n    delete n.f, delete n.g, delete n.h, delete n.cost, delete n.visited, delete n.closed, delete n.parent;\n  }\n}, n.heap = function () {\n  return new t(function (e) {\n    return e.f;\n  });\n}, n.search = function (e, t, n) {\n  this.init(e);\n  var r = this.heap();\n  for (r.push(t); r.size() > 0;) {\n    var o = r.pop();\n    if (o === n) {\n      for (var i = o, s = []; i.parent;) s.push(i), i = i.parent;\n      return this.cleanUp(s), s.reverse();\n    }\n    o.closed = !0;\n    for (var u = this.neighbours(e, o), c = 0, h = u.length; c < h; c++) {\n      var a = u[c];\n      if (!a.closed) {\n        var d = o.g + a.cost,\n          f = a.visited;\n        if (!f || d < a.g) {\n          if (a.visited = !0, a.parent = o, !a.centroid || !n.centroid) throw new Error(\"Unexpected state\");\n          a.h = a.h || this.heuristic(a.centroid, n.centroid), a.g = d, a.f = a.g + a.h, f ? r.rescoreElement(a) : r.push(a);\n        }\n      }\n    }\n  }\n  return [];\n}, n.heuristic = function (t, n) {\n  return e.distanceToSquared(t, n);\n}, n.neighbours = function (e, t) {\n  for (var n = [], r = 0; r < t.neighbours.length; r++) n.push(e[t.neighbours[r]]);\n  return n;\n};\nvar r = 1,\n  o = function o() {};\no.buildZone = function (t) {\n  var n = this,\n    r = this._buildNavigationMesh(t),\n    o = {};\n  r.vertices.forEach(function (t) {\n    t.x = e.roundNumber(t.x, 2), t.y = e.roundNumber(t.y, 2), t.z = e.roundNumber(t.z, 2);\n  }), o.vertices = r.vertices;\n  var i = this._buildPolygonGroups(r);\n  o.groups = [];\n  var s = function s(e, t) {\n    for (var n = 0; n < e.length; n++) if (t === e[n]) return n;\n  };\n  return i.forEach(function (t) {\n    var r = [];\n    t.forEach(function (o) {\n      var i = o.neighbours.map(function (e) {\n          return s(t, e);\n        }),\n        u = o.neighbours.map(function (e) {\n          return n._getSharedVerticesInOrder(o, e);\n        });\n      o.centroid.x = e.roundNumber(o.centroid.x, 2), o.centroid.y = e.roundNumber(o.centroid.y, 2), o.centroid.z = e.roundNumber(o.centroid.z, 2), r.push({\n        id: s(t, o),\n        neighbours: i,\n        vertexIds: o.vertexIds,\n        centroid: o.centroid,\n        portals: u\n      });\n    }), o.groups.push(r);\n  }), o;\n}, o._buildNavigationMesh = function (t) {\n  return e.computeCentroids(t), t.mergeVertices(), this._buildPolygonsFromGeometry(t);\n}, o._buildPolygonGroups = function (e) {\n  var t = [],\n    n = 0,\n    r = function r(e) {\n      e.neighbours.forEach(function (t) {\n        void 0 === t.group && (t.group = e.group, r(t));\n      });\n    };\n  return e.polygons.forEach(function (e) {\n    void 0 === e.group && (e.group = n++, r(e)), t[e.group] || (t[e.group] = []), t[e.group].push(e);\n  }), t;\n}, o._buildPolygonNeighbours = function (e, t, n) {\n  var r = new Set(),\n    o = n.get(e.vertexIds[0]),\n    i = n.get(e.vertexIds[1]),\n    s = n.get(e.vertexIds[2]);\n  o.forEach(function (e) {\n    (i.has(e) || s.has(e)) && r.add(t.polygons[e]);\n  }), i.forEach(function (e) {\n    s.has(e) && r.add(t.polygons[e]);\n  }), e.neighbours = Array.from(r);\n}, o._buildPolygonsFromGeometry = function (e) {\n  for (var t = this, n = [], o = e.vertices, i = e.faceVertexUvs, s = new Map(), u = 0; u < o.length; u++) s.set(u, new Set());\n  e.faces.forEach(function (e) {\n    n.push({\n      id: r++,\n      vertexIds: [e.a, e.b, e.c],\n      centroid: e.centroid,\n      normal: e.normal,\n      neighbours: []\n    }), s.get(e.a).add(n.length - 1), s.get(e.b).add(n.length - 1), s.get(e.c).add(n.length - 1);\n  });\n  var c = {\n    polygons: n,\n    vertices: o,\n    faceVertexUvs: i\n  };\n  return n.forEach(function (e) {\n    t._buildPolygonNeighbours(e, c, s);\n  }), c;\n}, o._getSharedVerticesInOrder = function (e, t) {\n  var n = e.vertexIds,\n    r = t.vertexIds,\n    o = new Set();\n  if (n.forEach(function (e) {\n    r.includes(e) && o.add(e);\n  }), o.size < 2) return [];\n  o.has(n[0]) && o.has(n[n.length - 1]) && n.push(n.shift()), o.has(r[0]) && o.has(r[r.length - 1]) && r.push(r.shift());\n  var i = [];\n  return n.forEach(function (e) {\n    r.includes(e) && i.push(e);\n  }), i;\n};\nvar i = function i() {\n  this.portals = [];\n};\ni.prototype.push = function (e, t) {\n  void 0 === t && (t = e), this.portals.push({\n    left: e,\n    right: t\n  });\n}, i.prototype.stringPull = function () {\n  var t,\n    n,\n    r,\n    o = this.portals,\n    i = [],\n    s = 0,\n    u = 0,\n    c = 0;\n  n = o[0].left, r = o[0].right, i.push(t = o[0].left);\n  for (var h = 1; h < o.length; h++) {\n    var a = o[h].left,\n      d = o[h].right;\n    if (e.triarea2(t, r, d) <= 0) {\n      if (!(e.vequal(t, r) || e.triarea2(t, n, d) > 0)) {\n        i.push(n), n = t = n, r = t, u = s = u, c = s, h = s;\n        continue;\n      }\n      r = d, c = h;\n    }\n    if (e.triarea2(t, n, a) >= 0) {\n      if (!(e.vequal(t, n) || e.triarea2(t, r, a) < 0)) {\n        i.push(r), n = t = r, r = t, u = s = c, c = s, h = s;\n        continue;\n      }\n      n = a, u = h;\n    }\n  }\n  return 0 !== i.length && e.vequal(i[i.length - 1], o[o.length - 1].left) || i.push(o[o.length - 1].left), this.path = i, i;\n};\nvar s,\n  u,\n  c,\n  h,\n  a,\n  d,\n  f = function f() {\n    this.zones = {};\n  };\nf.createZone = function (e) {\n  return o.buildZone(e);\n}, f.prototype.setZoneData = function (e, t) {\n  this.zones[e] = t;\n}, f.prototype.getGroup = function (t, n) {\n  if (!this.zones[t]) return null;\n  var r = null,\n    o = Math.pow(50, 2);\n  return this.zones[t].groups.forEach(function (t, i) {\n    t.forEach(function (t) {\n      var s = e.distanceToSquared(t.centroid, n);\n      s < o && (r = i, o = s);\n    });\n  }), r;\n}, f.prototype.getRandomNode = function (t, n, r, o) {\n  if (!this.zones[t]) return new THREE.Vector3();\n  r = r || null, o = o || 0;\n  var i = [];\n  return this.zones[t].groups[n].forEach(function (t) {\n    r && o ? e.distanceToSquared(r, t.centroid) < o * o && i.push(t.centroid) : i.push(t.centroid);\n  }), e.sample(i) || new THREE.Vector3();\n}, f.prototype.getClosestNode = function (t, n, r, o) {\n  void 0 === o && (o = !1);\n  var i = this.zones[n].vertices,\n    s = null,\n    u = Infinity;\n  return this.zones[n].groups[r].forEach(function (n) {\n    var r = e.distanceToSquared(n.centroid, t);\n    r < u && (!o || e.isVectorInPolygon(t, n, i)) && (s = n, u = r);\n  }), s;\n}, f.prototype.findPath = function (e, t, r, o) {\n  var s = this.zones[r].groups[o],\n    u = this.zones[r].vertices,\n    c = this.getClosestNode(e, r, o),\n    h = this.getClosestNode(t, r, o, !0);\n  if (!c || !h) return null;\n  var a = n.search(s, c, h),\n    d = function d(e, t) {\n      for (var n = 0; n < e.neighbours.length; n++) if (e.neighbours[n] === t.id) return e.portals[n];\n    },\n    f = new i();\n  f.push(e);\n  for (var l = 0; l < a.length; l++) {\n    var v = a[l + 1];\n    if (v) {\n      var p = d(a[l], v);\n      f.push(u[p[0]], u[p[1]]);\n    }\n  }\n  f.push(t), f.stringPull();\n  var g = f.path.map(function (e) {\n    return new THREE.Vector3(e.x, e.y, e.z);\n  });\n  return g.shift(), g;\n}, f.prototype.clampStep = (c = new THREE.Vector3(), h = new THREE.Plane(), a = new THREE.Triangle(), d = new THREE.Vector3(), function (e, t, n, r, o, i) {\n  var f = this.zones[r].vertices,\n    l = this.zones[r].groups[o],\n    v = [n],\n    p = {};\n  p[n.id] = 0, s = void 0, d.set(0, 0, 0), u = Infinity, h.setFromCoplanarPoints(f[n.vertexIds[0]], f[n.vertexIds[1]], f[n.vertexIds[2]]), h.projectPoint(t, c), t.copy(c);\n  for (var g = v.pop(); g; g = v.pop()) {\n    a.set(f[g.vertexIds[0]], f[g.vertexIds[1]], f[g.vertexIds[2]]), a.closestPointToPoint(t, c), c.distanceToSquared(t) < u && (s = g, d.copy(c), u = c.distanceToSquared(t));\n    var x = p[g];\n    if (!(x > 2)) for (var I = 0; I < g.neighbours.length; I++) {\n      var b = l[g.neighbours[I]];\n      b.id in p || (v.push(b), p[b.id] = x + 1);\n    }\n  }\n  return i.copy(d), s;\n});\nexport { f as Pathfinding };","map":{"version":3,"names":["e","computeCentroids","t","n","r","faces","length","centroid","THREE","Vector3","add","vertices","a","b","c","divideScalar","roundNumber","Number","toFixed","sample","Math","floor","random","mergeVertexIds","forEach","indexOf","push","includes","shift","o","i","slice","s","u","Error","pop","concat","setPolygonCentroid","vertexIds","copy","cleanPolygon","h","clone","sub","d","angleTo","PI","f","neighbours","isConvex","cross","y","distanceToSquared","x","z","isPointInPoly","isVectorInPolygon","min","max","triarea2","vequal","content","scoreFunction","prototype","sinkDown","bubbleUp","remove","size","rescoreElement","init","g","cost","visited","closed","parent","cleanUp","heap","search","reverse","heuristic","buildZone","_buildNavigationMesh","_buildPolygonGroups","groups","map","_getSharedVerticesInOrder","id","portals","mergeVertices","_buildPolygonsFromGeometry","group","polygons","_buildPolygonNeighbours","Set","get","has","Array","from","faceVertexUvs","Map","set","normal","left","right","stringPull","path","zones","createZone","setZoneData","getGroup","pow","getRandomNode","getClosestNode","Infinity","findPath","l","v","p","clampStep","Plane","Triangle","setFromCoplanarPoints","projectPoint","closestPointToPoint","I","Pathfinding"],"sources":["/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/three-pathfinding/src/Utils.js","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/three-pathfinding/src/BinaryHeap.js","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/three-pathfinding/src/AStar.js","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/three-pathfinding/src/Builder.js","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/three-pathfinding/src/Channel.js","/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/three-pathfinding/src/index.js"],"sourcesContent":["class Utils {\n\n  static computeCentroids (geometry) {\n    var f, fl, face;\n\n    for ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\n      face = geometry.faces[ f ];\n      face.centroid = new THREE.Vector3( 0, 0, 0 );\n\n      face.centroid.add( geometry.vertices[ face.a ] );\n      face.centroid.add( geometry.vertices[ face.b ] );\n      face.centroid.add( geometry.vertices[ face.c ] );\n      face.centroid.divideScalar( 3 );\n\n    }\n  }\n\n  static roundNumber (value, decimals) {\n    return Number(value.toFixed(decimals));\n  }\n\n  static sample (list) {\n    return list[Math.floor(Math.random() * list.length)];\n  }\n\n  static mergeVertexIds (aList, bList) {\n\n    var sharedVertices = [];\n\n    aList.forEach((vID) => {\n      if (bList.indexOf(vID) >= 0) {\n        sharedVertices.push(vID);\n      }\n    });\n\n    if (sharedVertices.length < 2) return [];\n\n    if (sharedVertices.includes(aList[0]) && sharedVertices.includes(aList[aList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      aList.push(aList.shift());\n    }\n\n    if (sharedVertices.includes(bList[0]) && sharedVertices.includes(bList[bList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      bList.push(bList.shift());\n    }\n\n    // Again!\n    sharedVertices = [];\n\n    aList.forEach((vId) => {\n      if (bList.includes(vId)) {\n        sharedVertices.push(vId);\n      }\n    });\n\n    var clockwiseMostSharedVertex = sharedVertices[1];\n    var counterClockwiseMostSharedVertex = sharedVertices[0];\n\n\n    var cList = aList.slice();\n    while (cList[0] !== clockwiseMostSharedVertex) {\n      cList.push(cList.shift());\n    }\n\n    var c = 0;\n\n    var temp = bList.slice();\n    while (temp[0] !== counterClockwiseMostSharedVertex) {\n      temp.push(temp.shift());\n\n      if (c++ > 10) throw new Error('Unexpected state');\n    }\n\n    // Shave\n    temp.shift();\n    temp.pop();\n\n    cList = cList.concat(temp);\n\n    return cList;\n  }\n\n  static setPolygonCentroid (polygon, navigationMesh) {\n    var sum = new THREE.Vector3();\n\n    var vertices = navigationMesh.vertices;\n\n    polygon.vertexIds.forEach((vId) => {\n      sum.add(vertices[vId]);\n    });\n\n    sum.divideScalar(polygon.vertexIds.length);\n\n    polygon.centroid.copy(sum);\n  }\n\n  static cleanPolygon (polygon, navigationMesh) {\n\n    var newVertexIds = [];\n\n    var vertices = navigationMesh.vertices;\n\n    for (var i = 0; i < polygon.vertexIds.length; i++) {\n\n      var vertex = vertices[polygon.vertexIds[i]];\n\n      var nextVertexId, previousVertexId;\n      var nextVertex, previousVertex;\n\n      if (i === 0) {\n        nextVertexId = polygon.vertexIds[1];\n        previousVertexId = polygon.vertexIds[polygon.vertexIds.length - 1];\n      } else if (i === polygon.vertexIds.length - 1) {\n        nextVertexId = polygon.vertexIds[0];\n        previousVertexId = polygon.vertexIds[polygon.vertexIds.length - 2];\n      } else {\n        nextVertexId = polygon.vertexIds[i + 1];\n        previousVertexId = polygon.vertexIds[i - 1];\n      }\n\n      nextVertex = vertices[nextVertexId];\n      previousVertex = vertices[previousVertexId];\n\n      var a = nextVertex.clone().sub(vertex);\n      var b = previousVertex.clone().sub(vertex);\n\n      var angle = a.angleTo(b);\n\n      if (angle > Math.PI - 0.01 && angle < Math.PI + 0.01) {\n\n        // Remove the neighbours who had this vertex\n        var goodNeighbours = [];\n        polygon.neighbours.forEach((neighbour) => {\n          if (!neighbour.vertexIds.includes(polygon.vertexIds[i])) {\n            goodNeighbours.push(neighbour);\n          }\n        });\n        polygon.neighbours = goodNeighbours;\n\n\n        // TODO cleanup the list of vertices and rebuild vertexIds for all polygons\n      } else {\n        newVertexIds.push(polygon.vertexIds[i]);\n      }\n\n    }\n\n    polygon.vertexIds = newVertexIds;\n\n    this.setPolygonCentroid(polygon, navigationMesh);\n\n  }\n\n  static isConvex (polygon, navigationMesh) {\n\n    var vertices = navigationMesh.vertices;\n\n    if (polygon.vertexIds.length < 3) return false;\n\n    var convex = true;\n\n    var total = 0;\n\n    var results = [];\n\n    for (var i = 0; i < polygon.vertexIds.length; i++) {\n\n      var vertex = vertices[polygon.vertexIds[i]];\n\n      var nextVertex, previousVertex;\n\n      if (i === 0) {\n        nextVertex = vertices[polygon.vertexIds[1]];\n        previousVertex = vertices[polygon.vertexIds[polygon.vertexIds.length - 1]];\n      } else if (i === polygon.vertexIds.length - 1) {\n        nextVertex = vertices[polygon.vertexIds[0]];\n        previousVertex = vertices[polygon.vertexIds[polygon.vertexIds.length - 2]];\n      } else {\n        nextVertex = vertices[polygon.vertexIds[i + 1]];\n        previousVertex = vertices[polygon.vertexIds[i - 1]];\n      }\n\n      var a = nextVertex.clone().sub(vertex);\n      var b = previousVertex.clone().sub(vertex);\n\n      var angle = a.angleTo(b);\n      total += angle;\n\n      if (angle === Math.PI || angle === 0) return false;\n\n      var r = a.cross(b).y;\n      results.push(r);\n    }\n\n    // if ( total > (polygon.vertexIds.length-2)*Math.PI ) return false;\n\n    results.forEach((r) => {\n      if (r === 0) convex = false;\n    });\n\n    if (results[0] > 0) {\n      results.forEach((r) => {\n        if (r < 0) convex = false;\n      });\n    } else {\n      results.forEach((r) => {\n        if (r > 0) convex = false;\n      });\n    }\n\n    return convex;\n  }\n\n  static distanceToSquared (a, b) {\n\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    var dz = a.z - b.z;\n\n    return dx * dx + dy * dy + dz * dz;\n\n  }\n\n  //+ Jonas Raoni Soares Silva\n  //@ http://jsfromhell.com/math/is-point-in-poly [rev. #0]\n  static isPointInPoly (poly, pt) {\n    for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)\n      ((poly[i].z <= pt.z && pt.z < poly[j].z) || (poly[j].z <= pt.z && pt.z < poly[i].z)) && (pt.x < (poly[j].x - poly[i].x) * (pt.z - poly[i].z) / (poly[j].z - poly[i].z) + poly[i].x) && (c = !c);\n    return c;\n  }\n\n  static isVectorInPolygon (vector, polygon, vertices) {\n\n    // reference point will be the centroid of the polygon\n    // We need to rotate the vector as well as all the points which the polygon uses\n\n    var lowestPoint = 100000;\n    var highestPoint = -100000;\n\n    var polygonVertices = [];\n\n    polygon.vertexIds.forEach((vId) => {\n      lowestPoint = Math.min(vertices[vId].y, lowestPoint);\n      highestPoint = Math.max(vertices[vId].y, highestPoint);\n      polygonVertices.push(vertices[vId]);\n    });\n\n    if (vector.y < highestPoint + 0.5 && vector.y > lowestPoint - 0.5 &&\n      this.isPointInPoly(polygonVertices, vector)) {\n      return true;\n    }\n    return false;\n  }\n\n  static triarea2 (a, b, c) {\n    var ax = b.x - a.x;\n    var az = b.z - a.z;\n    var bx = c.x - a.x;\n    var bz = c.z - a.z;\n    return bx * az - ax * bz;\n  }\n\n  static vequal (a, b) {\n    return this.distanceToSquared(a, b) < 0.00001;\n  }\n}\n\nexport { Utils };\n","// javascript-astar\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a binary heap.\n\nclass BinaryHeap {\n  constructor (scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  }\n\n  pop () {\n    // Store the first element so we can return it later.\n    const result = this.content[0];\n    // Get the element at the end of the array.\n    const end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  }\n\n  remove (node) {\n    const i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    const end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  }\n\n  size () {\n    return this.content.length;\n  }\n\n  rescoreElement (node) {\n    this.sinkDown(this.content.indexOf(node));\n  }\n\n  sinkDown (n) {\n    // Fetch the element that has to be sunk.\n    const element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      const parentN = ((n + 1) >> 1) - 1;\n      const parent = this.content[parentN];\n\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        // Swap the elements if the parent is greater.\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      } else {\n        // Found a parent that is less, no need to sink any further.\n        break;\n      }\n    }\n  }\n\n  bubbleUp (n) {\n    // Look up the target element and its score.\n    const length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      const child2N = (n + 1) << 1,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      let swap = null;\n      let child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        const child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        const child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n\n}\n\nexport { BinaryHeap };\n","import { BinaryHeap } from './BinaryHeap';\nimport { Utils } from './Utils.js';\n\nclass AStar {\n  static init (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      //for(var x in graph) {\n      const node = graph[x];\n      node.f = 0;\n      node.g = 0;\n      node.h = 0;\n      node.cost = 1.0;\n      node.visited = false;\n      node.closed = false;\n      node.parent = null;\n    }\n  }\n\n  static cleanUp (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      const node = graph[x];\n      delete node.f;\n      delete node.g;\n      delete node.h;\n      delete node.cost;\n      delete node.visited;\n      delete node.closed;\n      delete node.parent;\n    }\n  }\n\n  static heap () {\n    return new BinaryHeap(function (node) {\n      return node.f;\n    });\n  }\n\n  static search (graph, start, end) {\n    this.init(graph);\n    //heuristic = heuristic || astar.manhattan;\n\n\n    const openHeap = this.heap();\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      const currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        let curr = currentNode;\n        const ret = [];\n        while (curr.parent) {\n          ret.push(curr);\n          curr = curr.parent;\n        }\n        this.cleanUp(ret);\n        return ret.reverse();\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbours.\n      currentNode.closed = true;\n\n      // Find all neighbours for the current node. Optionally find diagonal neighbours as well (false by default).\n      const neighbours = this.neighbours(graph, currentNode);\n\n      for (let i = 0, il = neighbours.length; i < il; i++) {\n        const neighbour = neighbours[i];\n\n        if (neighbour.closed) {\n          // Not a valid node to process, skip to next neighbour.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbour is the shortest one we have seen yet.\n        const gScore = currentNode.g + neighbour.cost;\n        const beenVisited = neighbour.visited;\n\n        if (!beenVisited || gScore < neighbour.g) {\n\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbour.visited = true;\n          neighbour.parent = currentNode;\n          if (!neighbour.centroid || !end.centroid) throw new Error('Unexpected state');\n          neighbour.h = neighbour.h || this.heuristic(neighbour.centroid, end.centroid);\n          neighbour.g = gScore;\n          neighbour.f = neighbour.g + neighbour.h;\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbour);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbour);\n          }\n        }\n      }\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  }\n\n  static heuristic (pos1, pos2) {\n    return Utils.distanceToSquared(pos1, pos2);\n  }\n\n  static neighbours (graph, node) {\n    const ret = [];\n\n    for (let e = 0; e < node.neighbours.length; e++) {\n      ret.push(graph[node.neighbours[e]]);\n    }\n\n    return ret;\n  }\n}\n\nexport { AStar };\n","import { Utils } from './Utils';\n\nlet polygonId = 1;\n\nclass Builder {\n  /**\n   * Constructs groups from the given navigation mesh.\n   * @param  {THREE.Geometry} geometry\n   * @return {Zone}\n   */\n  static buildZone (geometry) {\n\n    const navMesh = this._buildNavigationMesh(geometry);\n\n    const zone = {};\n\n    navMesh.vertices.forEach((v) => {\n      v.x = Utils.roundNumber(v.x, 2);\n      v.y = Utils.roundNumber(v.y, 2);\n      v.z = Utils.roundNumber(v.z, 2);\n    });\n\n    zone.vertices = navMesh.vertices;\n\n    const groups = this._buildPolygonGroups(navMesh);\n\n    zone.groups = [];\n\n    const findPolygonIndex = function (group, p) {\n      for (let i = 0; i < group.length; i++) {\n        if (p === group[i]) return i;\n      }\n    };\n\n    // TODO: This block represents 50-60% of navigation mesh construction time,\n    // and could probably be optimized. For example, construct portals while\n    // determining the neighbor graph.\n    groups.forEach((group) => {\n\n      const newGroup = [];\n\n      group.forEach((p) => {\n\n        // TODO: Optimize.\n        const neighbours = p.neighbours.map((n) => findPolygonIndex(group, n));\n\n        // Build a portal list to each neighbour\n        const portals = p.neighbours.map((n) => this._getSharedVerticesInOrder(p, n));\n\n        p.centroid.x = Utils.roundNumber(p.centroid.x, 2);\n        p.centroid.y = Utils.roundNumber(p.centroid.y, 2);\n        p.centroid.z = Utils.roundNumber(p.centroid.z, 2);\n\n        newGroup.push({\n          id: findPolygonIndex(group, p),\n          neighbours: neighbours,\n          vertexIds: p.vertexIds,\n          centroid: p.centroid,\n          portals: portals\n        });\n\n      });\n\n      zone.groups.push(newGroup);\n    });\n\n    return zone;\n  }\n\n  /**\n   * Constructs a navigation mesh from the given geometry.\n   * @param {THREE.Geometry} geometry\n   * @return {Object}\n   */\n  static _buildNavigationMesh (geometry) {\n    Utils.computeCentroids(geometry);\n    geometry.mergeVertices();\n    return this._buildPolygonsFromGeometry(geometry);\n  }\n\n  static _buildPolygonGroups (navigationMesh) {\n\n    const polygons = navigationMesh.polygons;\n\n    const polygonGroups = [];\n    let groupCount = 0;\n\n    const spreadGroupId = function (polygon) {\n      polygon.neighbours.forEach((neighbour) => {\n        if (neighbour.group === undefined) {\n          neighbour.group = polygon.group;\n          spreadGroupId(neighbour);\n        }\n      });\n    };\n\n    polygons.forEach((polygon) => {\n\n      if (polygon.group === undefined) {\n        polygon.group = groupCount++;\n        // Spread it\n        spreadGroupId(polygon);\n      }\n\n      if (!polygonGroups[polygon.group]) polygonGroups[polygon.group] = [];\n\n      polygonGroups[polygon.group].push(polygon);\n    });\n\n    return polygonGroups;\n  }\n\n  static _buildPolygonNeighbours (polygon, navigationMesh, vertexPolygonMap) {\n    const neighbors = new Set();\n\n    const groupA = vertexPolygonMap.get(polygon.vertexIds[0]);\n    const groupB = vertexPolygonMap.get(polygon.vertexIds[1]);\n    const groupC = vertexPolygonMap.get(polygon.vertexIds[2]);\n\n    // It's only necessary to iterate groups A and B. Polygons contained only\n    // in group C cannot share a >1 vertex with this polygon.\n    // IMPORTANT: Bublé cannot compile for-of loops.\n    groupA.forEach((candidate) => {\n      if (groupB.has(candidate) || groupC.has(candidate)) {\n        neighbors.add(navigationMesh.polygons[candidate]);\n      }\n    });\n    groupB.forEach((candidate) => {\n      if (groupC.has(candidate)) {\n        neighbors.add(navigationMesh.polygons[candidate]);\n      }\n    });\n\n    polygon.neighbours = Array.from(neighbors);\n  }\n\n  static _buildPolygonsFromGeometry (geometry) {\n\n    const polygons = [];\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n\n    // Constructing the neighbor graph brute force is O(n²). To avoid that,\n    // create a map from vertices to the polygons that contain them, and use it\n    // while connecting polygons. This reduces complexity to O(n*m), where 'm'\n    // is related to connectivity of the mesh.\n    const vertexPolygonMap = new Map(); // Map<vertexID, Set<polygonIndex>>\n    for (let i = 0; i < vertices.length; i++) {\n      vertexPolygonMap.set(i, new Set());\n    }\n\n    // Convert the faces into a custom format that supports more than 3 vertices\n    geometry.faces.forEach((face) => {\n      polygons.push({\n        id: polygonId++,\n        vertexIds: [face.a, face.b, face.c],\n        centroid: face.centroid,\n        normal: face.normal,\n        neighbours: []\n      });\n      vertexPolygonMap.get(face.a).add(polygons.length - 1);\n      vertexPolygonMap.get(face.b).add(polygons.length - 1);\n      vertexPolygonMap.get(face.c).add(polygons.length - 1);\n    });\n\n    const navigationMesh = {\n      polygons: polygons,\n      vertices: vertices,\n      faceVertexUvs: faceVertexUvs\n    };\n\n    // Build a list of adjacent polygons\n    polygons.forEach((polygon) => {\n      this._buildPolygonNeighbours(polygon, navigationMesh, vertexPolygonMap);\n    });\n\n    return navigationMesh;\n  }\n\n  static _getSharedVerticesInOrder (a, b) {\n\n    const aList = a.vertexIds;\n    const bList = b.vertexIds;\n\n    const sharedVertices = new Set();\n\n    aList.forEach((vId) => {\n      if (bList.includes(vId)) {\n        sharedVertices.add(vId);\n      }\n    });\n\n    if (sharedVertices.size < 2) return [];\n\n    if (sharedVertices.has(aList[0]) && sharedVertices.has(aList[aList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      aList.push(aList.shift());\n    }\n\n    if (sharedVertices.has(bList[0]) && sharedVertices.has(bList[bList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      bList.push(bList.shift());\n    }\n\n    // Again!\n    const sharedVerticesOrdered = [];\n\n    aList.forEach((vId) => {\n      if (bList.includes(vId)) {\n        sharedVerticesOrdered.push(vId);\n      }\n    });\n\n    return sharedVerticesOrdered;\n  }\n}\n\nexport { Builder };\n","import { Utils } from './Utils';\n\nclass Channel {\n  constructor () {\n    this.portals = [];\n  }\n\n  push (p1, p2) {\n    if (p2 === undefined) p2 = p1;\n    this.portals.push({\n      left: p1,\n      right: p2\n    });\n  }\n\n  stringPull () {\n    const portals = this.portals;\n    const pts = [];\n    // Init scan state\n    let portalApex, portalLeft, portalRight;\n    let apexIndex = 0,\n      leftIndex = 0,\n      rightIndex = 0;\n\n    portalApex = portals[0].left;\n    portalLeft = portals[0].left;\n    portalRight = portals[0].right;\n\n    // Add start point.\n    pts.push(portalApex);\n\n    for (let i = 1; i < portals.length; i++) {\n      const left = portals[i].left;\n      const right = portals[i].right;\n\n      // Update right vertex.\n      if (Utils.triarea2(portalApex, portalRight, right) <= 0.0) {\n        if (Utils.vequal(portalApex, portalRight) || Utils.triarea2(portalApex, portalLeft, right) > 0.0) {\n          // Tighten the funnel.\n          portalRight = right;\n          rightIndex = i;\n        } else {\n          // Right over left, insert left to path and restart scan from portal left point.\n          pts.push(portalLeft);\n          // Make current left the new apex.\n          portalApex = portalLeft;\n          apexIndex = leftIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n\n      // Update left vertex.\n      if (Utils.triarea2(portalApex, portalLeft, left) >= 0.0) {\n        if (Utils.vequal(portalApex, portalLeft) || Utils.triarea2(portalApex, portalRight, left) < 0.0) {\n          // Tighten the funnel.\n          portalLeft = left;\n          leftIndex = i;\n        } else {\n          // Left over right, insert right to path and restart scan from portal right point.\n          pts.push(portalRight);\n          // Make current right the new apex.\n          portalApex = portalRight;\n          apexIndex = rightIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n    }\n\n    if ((pts.length === 0) || (!Utils.vequal(pts[pts.length - 1], portals[portals.length - 1].left))) {\n      // Append last point to path.\n      pts.push(portals[portals.length - 1].left);\n    }\n\n    this.path = pts;\n    return pts;\n  }\n}\n\nexport { Channel };\n","/* global THREE */\n\nimport { Utils } from './Utils';\nimport { AStar } from './AStar';\nimport { Builder } from './Builder';\nimport { Channel } from './Channel';\n\n/**\n * Defines an instance of the pathfinding module, with one or more zones.\n */\nclass Pathfinding {\n\tconstructor () {\n\t\tthis.zones = {};\n\t}\n\n\t/**\n\t * (Static) Builds a zone/node set from navigation mesh geometry.\n\t * @param  {THREE.Geometry} geometry\n\t * @return {Zone}\n\t */\n\tstatic createZone (geometry) {\n\t\treturn Builder.buildZone(geometry);\n\t}\n\n\t/**\n\t * Sets data for the given zone.\n\t * @param {string} zoneID\n\t * @param {Zone} zone\n\t */\n\tsetZoneData (zoneID, zone) {\n\t\tthis.zones[zoneID] = zone;\n\t}\n\n\t/**\n\t * Returns closest node group ID for given position.\n\t * @param  {string} zoneID\n\t * @param  {THREE.Vector3} position\n\t * @return {number}\n\t */\n\tgetGroup (zoneID, position) {\n\t\tif (!this.zones[zoneID]) return null;\n\n\t\tlet closestNodeGroup = null;\n\t\tlet distance = Math.pow(50, 2);\n\n\t\tthis.zones[zoneID].groups.forEach((group, index) => {\n\t\t\tgroup.forEach((node) => {\n\t\t\t\tconst measuredDistance = Utils.distanceToSquared(node.centroid, position);\n\t\t\t\tif (measuredDistance < distance) {\n\t\t\t\t\tclosestNodeGroup = index;\n\t\t\t\t\tdistance = measuredDistance;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn closestNodeGroup;\n\t}\n\n\t/**\n\t * Returns a random node within a given range of a given position.\n\t * @param  {string} zoneID\n\t * @param  {number} groupID\n\t * @param  {THREE.Vector3} nearPosition\n\t * @param  {number} nearRange\n\t * @return {Node}\n\t */\n\tgetRandomNode (zoneID, groupID, nearPosition, nearRange) {\n\n\t\tif (!this.zones[zoneID]) return new THREE.Vector3();\n\n\t\tnearPosition = nearPosition || null;\n\t\tnearRange = nearRange || 0;\n\n\t\tconst candidates = [];\n\t\tconst polygons = this.zones[zoneID].groups[groupID];\n\n\t\tpolygons.forEach((p) => {\n\t\t\tif (nearPosition && nearRange) {\n\t\t\t\tif (Utils.distanceToSquared(nearPosition, p.centroid) < nearRange * nearRange) {\n\t\t\t\t\tcandidates.push(p.centroid);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcandidates.push(p.centroid);\n\t\t\t}\n\t\t});\n\n\t\treturn Utils.sample(candidates) || new THREE.Vector3();\n\t}\n\n\t/**\n\t * Returns the closest node to the target position.\n\t * @param  {THREE.Vector3} position\n\t * @param  {string}  zoneID\n\t * @param  {number}  groupID\n\t * @param  {boolean} checkPolygon\n\t * @return {Node}\n\t */\n\tgetClosestNode (position, zoneID, groupID, checkPolygon = false) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tlet closestNode = null;\n\t\tlet closestDistance = Infinity;\n\n\t\tnodes.forEach((node) => {\n\t\t\tconst distance = Utils.distanceToSquared(node.centroid, position);\n\t\t\tif (distance < closestDistance\n\t\t\t\t\t&& (!checkPolygon || Utils.isVectorInPolygon(position, node, vertices))) {\n\t\t\t\tclosestNode = node;\n\t\t\t\tclosestDistance = distance;\n\t\t\t}\n\t\t});\n\n\t\treturn closestNode;\n\t}\n\n\t/**\n\t * Returns a path between given start and end points. If a complete path\n\t * cannot be found, will return the nearest endpoint available.\n\t *\n\t * @param  {THREE.Vector3} startPosition Start position.\n\t * @param  {THREE.Vector3} targetPosition Destination.\n\t * @param  {string} zoneID ID of current zone.\n\t * @param  {number} groupID Current group ID.\n\t * @return {Array<THREE.Vector3>} Array of points defining the path.\n\t */\n\tfindPath (startPosition, targetPosition, zoneID, groupID) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\n\t\tconst closestNode = this.getClosestNode(startPosition, zoneID, groupID);\n\t\tconst farthestNode = this.getClosestNode(targetPosition, zoneID, groupID, true);\n\n\t\t// If we can't find any node, just go straight to the target\n\t\tif (!closestNode || !farthestNode) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst paths = AStar.search(nodes, closestNode, farthestNode);\n\n\t\tconst getPortalFromTo = function (a, b) {\n\t\t\tfor (var i = 0; i < a.neighbours.length; i++) {\n\t\t\t\tif (a.neighbours[i] === b.id) {\n\t\t\t\t\treturn a.portals[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// We have the corridor, now pull the rope.\n\t\tconst channel = new Channel();\n\t\tchannel.push(startPosition);\n\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\tconst polygon = paths[i];\n\t\t\tconst nextPolygon = paths[i + 1];\n\n\t\t\tif (nextPolygon) {\n\t\t\t\tconst portals = getPortalFromTo(polygon, nextPolygon);\n\t\t\t\tchannel.push(\n\t\t\t\t\tvertices[portals[0]],\n\t\t\t\t\tvertices[portals[1]]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tchannel.push(targetPosition);\n\t\tchannel.stringPull();\n\n\t\t// Return the path, omitting first position (which is already known).\n\t\tconst path = channel.path.map((c) => new THREE.Vector3(c.x, c.y, c.z));\n\t\tpath.shift();\n\t\treturn path;\n\t}\n}\n\n/**\n * Clamps a step along the navmesh, given start and desired endpoint. May be\n * used to constrain first-person / WASD controls.\n *\n * @param  {THREE.Vector3} start\n * @param  {THREE.Vector3} end Desired endpoint.\n * @param  {Node} node\n * @param  {string} zoneID\n * @param  {number} groupID\n * @param  {THREE.Vector3} endTarget Updated endpoint.\n * @return {Node} Updated node.\n */\nPathfinding.prototype.clampStep = (function () {\n\tconst point = new THREE.Vector3();\n\tconst plane = new THREE.Plane();\n\tconst triangle = new THREE.Triangle();\n\n\tlet closestNode;\n\tlet closestPoint = new THREE.Vector3();\n\tlet closestDistance;\n\n\treturn function (start, end, node, zoneID, groupID, endTarget) {\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\n\t\tconst nodeQueue = [node];\n\t\tconst nodeDepth = {};\n\t\tnodeDepth[node.id] = 0;\n\n\t\tclosestNode = undefined;\n\t\tclosestPoint.set(0, 0, 0);\n\t\tclosestDistance = Infinity;\n\n\t\t// Project the step along the current node.\n\t\tplane.setFromCoplanarPoints(\n\t\t\tvertices[node.vertexIds[0]],\n\t\t\tvertices[node.vertexIds[1]],\n\t\t\tvertices[node.vertexIds[2]]\n\t\t);\n\t\tplane.projectPoint(end, point);\n\t\tend.copy(point);\n\n\t\tfor (let currentNode = nodeQueue.pop(); currentNode; currentNode = nodeQueue.pop()) {\n\n\t\t\ttriangle.set(\n\t\t\t\tvertices[currentNode.vertexIds[0]],\n\t\t\t\tvertices[currentNode.vertexIds[1]],\n\t\t\t\tvertices[currentNode.vertexIds[2]]\n\t\t\t);\n\n\t\t\ttriangle.closestPointToPoint(end, point);\n\n\t\t\tif (point.distanceToSquared(end) < closestDistance) {\n\t\t\t\tclosestNode = currentNode;\n\t\t\t\tclosestPoint.copy(point);\n\t\t\t\tclosestDistance = point.distanceToSquared(end);\n\t\t\t}\n\n\t\t\tconst depth = nodeDepth[currentNode];\n\t\t\tif (depth > 2) continue;\n\n\t\t\tfor (let i = 0; i < currentNode.neighbours.length; i++) {\n\t\t\t\tconst neighbour = nodes[currentNode.neighbours[i]];\n\t\t\t\tif (neighbour.id in nodeDepth) continue;\n\n\t\t\t\tnodeQueue.push(neighbour);\n\t\t\t\tnodeDepth[neighbour.id] = depth + 1;\n\t\t\t}\n\t\t}\n\n\t\tendTarget.copy(closestPoint);\n\t\treturn closestNode;\n\t};\n}());\n\n/**\n * Defines a zone of interconnected groups on a navigation mesh.\n *\n * @type {Object}\n * @property {Array<Group>} groups\n * @property {Array<THREE.Vector3} vertices\n */\nconst Zone = {}; // jshint ignore:line\n\n/**\n * Defines a group within a navigation mesh.\n *\n * @type {Object}\n */\nconst Group = {}; // jshint ignore:line\n\n/**\n * Defines a node (or polygon) within a group.\n *\n * @type {Object}\n * @property {number} id\n * @property {Array<number>} neighbours IDs of neighboring nodes.\n * @property {Array<number} vertexIds\n * @property {THREE.Vector3} centroid\n * @property {Array<Array<number>>} portals Array of portals, each defined by two vertex IDs.\n * @property {boolean} closed\n * @property {number} cost\n */\nconst Node = {}; // jshint ignore:line\n\nexport { Pathfinding };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}