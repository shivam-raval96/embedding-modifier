{"ast":null,"code":"import _toConsumableArray from \"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nvar abs = Math.abs,\n  min = Math.min,\n  max = Math.max,\n  cos = Math.cos,\n  sin = Math.sin,\n  acos = Math.acos,\n  sqrt = Math.sqrt;\nvar pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nvar ZERO = {\n  x: 0,\n  y: 0,\n  z: 0\n};\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nvar Bezier = /*#__PURE__*/function () {\n  function Bezier(coords) {\n    _classCallCheck(this, Bezier);\n    var args = coords && coords.forEach ? coords : Array.from(arguments).slice();\n    var coordlen = false;\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      var newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n    var higher = false;\n    var len = args.length;\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n      }\n    }\n    var _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== \"undefined\";\n    var points = this.points = [];\n    for (var idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    var order = this.order = points.length - 1;\n    var dims = this.dims = [\"x\", \"y\"];\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    var aligned = utils.align(points, {\n      p1: points[0],\n      p2: points[order]\n    });\n    var baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce(function (t, p) {\n      return t + abs(p.y);\n    }, 0) < baselength / 50;\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n  _createClass(Bezier, [{\n    key: \"getUtils\",\n    value: function getUtils() {\n      return Bezier.getUtils();\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.toString();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return utils.pointsToString(this.points);\n    }\n  }, {\n    key: \"toSVG\",\n    value: function toSVG() {\n      if (this._3d) return false;\n      var p = this.points,\n        x = p[0].x,\n        y = p[0].y,\n        s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n      for (var i = 1, last = p.length; i < last; i++) {\n        s.push(p[i].x);\n        s.push(p[i].y);\n      }\n      return s.join(\" \");\n    }\n  }, {\n    key: \"setRatios\",\n    value: function setRatios(ratios) {\n      if (ratios.length !== this.points.length) {\n        throw new Error(\"incorrect number of ratio values\");\n      }\n      this.ratios = ratios;\n      this._lut = []; //  invalidate any precomputed LUT\n    }\n  }, {\n    key: \"verify\",\n    value: function verify() {\n      var print = this.coordDigest();\n      if (print !== this._print) {\n        this._print = print;\n        this.update();\n      }\n    }\n  }, {\n    key: \"coordDigest\",\n    value: function coordDigest() {\n      return this.points.map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      }).join(\"\");\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      // invalidate any precomputed LUT\n      this._lut = [];\n      this.dpoints = utils.derive(this.points, this._3d);\n      this.computedirection();\n    }\n  }, {\n    key: \"computedirection\",\n    value: function computedirection() {\n      var points = this.points;\n      var angle = utils.angle(points[0], points[this.order], points[1]);\n      this.clockwise = angle > 0;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return utils.length(this.derivative.bind(this));\n    }\n  }, {\n    key: \"getABC\",\n    value: function getABC(t, B) {\n      B = B || this.get(t);\n      var S = this.points[0];\n      var E = this.points[this.order];\n      return Bezier.getABC(this.order, S, B, E, t);\n    }\n  }, {\n    key: \"getLUT\",\n    value: function getLUT(steps) {\n      this.verify();\n      steps = steps || 100;\n      if (this._lut.length === steps + 1) {\n        return this._lut;\n      }\n      this._lut = [];\n      // n steps means n+1 points\n      steps++;\n      this._lut = [];\n      for (var i = 0, p, _t; i < steps; i++) {\n        _t = i / (steps - 1);\n        p = this.compute(_t);\n        p.t = _t;\n        this._lut.push(p);\n      }\n      return this._lut;\n    }\n  }, {\n    key: \"on\",\n    value: function on(point, error) {\n      error = error || 5;\n      var lut = this.getLUT(),\n        hits = [];\n      for (var i = 0, c, _t2 = 0; i < lut.length; i++) {\n        c = lut[i];\n        if (utils.dist(c, point) < error) {\n          hits.push(c);\n          _t2 += i / lut.length;\n        }\n      }\n      if (!hits.length) return false;\n      return t /= hits.length;\n    }\n  }, {\n    key: \"project\",\n    value: function project(point) {\n      // step 1: coarse check\n      var LUT = this.getLUT(),\n        l = LUT.length - 1,\n        closest = utils.closest(LUT, point),\n        mpos = closest.mpos,\n        t1 = (mpos - 1) / l,\n        t2 = (mpos + 1) / l,\n        step = 0.1 / l;\n\n      // step 2: fine check\n      var mdist = closest.mdist,\n        t = t1,\n        ft = t,\n        p;\n      mdist += 1;\n      for (var d; t < t2 + step; t += step) {\n        p = this.compute(t);\n        d = utils.dist(point, p);\n        if (d < mdist) {\n          mdist = d;\n          ft = t;\n        }\n      }\n      ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n      p = this.compute(ft);\n      p.t = ft;\n      p.d = mdist;\n      return p;\n    }\n  }, {\n    key: \"get\",\n    value: function get(t) {\n      return this.compute(t);\n    }\n  }, {\n    key: \"point\",\n    value: function point(idx) {\n      return this.points[idx];\n    }\n  }, {\n    key: \"compute\",\n    value: function compute(t) {\n      if (this.ratios) {\n        return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n      }\n      return utils.compute(t, this.points, this._3d, this.ratios);\n    }\n  }, {\n    key: \"raise\",\n    value: function raise() {\n      var p = this.points,\n        np = [p[0]],\n        k = p.length;\n      for (var i = 1, _pi, pim; i < k; i++) {\n        _pi = p[i];\n        pim = p[i - 1];\n        np[i] = {\n          x: (k - i) / k * _pi.x + i / k * pim.x,\n          y: (k - i) / k * _pi.y + i / k * pim.y\n        };\n      }\n      np[k] = p[k - 1];\n      return new Bezier(np);\n    }\n  }, {\n    key: \"derivative\",\n    value: function derivative(t) {\n      return utils.compute(t, this.dpoints[0], this._3d);\n    }\n  }, {\n    key: \"dderivative\",\n    value: function dderivative(t) {\n      return utils.compute(t, this.dpoints[1], this._3d);\n    }\n  }, {\n    key: \"align\",\n    value: function align() {\n      var p = this.points;\n      return new Bezier(utils.align(p, {\n        p1: p[0],\n        p2: p[p.length - 1]\n      }));\n    }\n  }, {\n    key: \"curvature\",\n    value: function curvature(t) {\n      return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n    }\n  }, {\n    key: \"inflections\",\n    value: function inflections() {\n      return utils.inflections(this.points);\n    }\n  }, {\n    key: \"normal\",\n    value: function normal(t) {\n      return this._3d ? this.__normal3(t) : this.__normal2(t);\n    }\n  }, {\n    key: \"__normal2\",\n    value: function __normal2(t) {\n      var d = this.derivative(t);\n      var q = sqrt(d.x * d.x + d.y * d.y);\n      return {\n        t: t,\n        x: -d.y / q,\n        y: d.x / q\n      };\n    }\n  }, {\n    key: \"__normal3\",\n    value: function __normal3(t) {\n      // see http://stackoverflow.com/questions/25453159\n      var r1 = this.derivative(t),\n        r2 = this.derivative(t + 0.01),\n        q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n        q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n      r1.x /= q1;\n      r1.y /= q1;\n      r1.z /= q1;\n      r2.x /= q2;\n      r2.y /= q2;\n      r2.z /= q2;\n      // cross product\n      var c = {\n        x: r2.y * r1.z - r2.z * r1.y,\n        y: r2.z * r1.x - r2.x * r1.z,\n        z: r2.x * r1.y - r2.y * r1.x\n      };\n      var m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n      c.x /= m;\n      c.y /= m;\n      c.z /= m;\n      // rotation matrix\n      var R = [c.x * c.x, c.x * c.y - c.z, c.x * c.z + c.y, c.x * c.y + c.z, c.y * c.y, c.y * c.z - c.x, c.x * c.z - c.y, c.y * c.z + c.x, c.z * c.z];\n      // normal vector:\n      var n = {\n        t: t,\n        x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n        y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n        z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n      };\n      return n;\n    }\n  }, {\n    key: \"hull\",\n    value: function hull(t) {\n      var p = this.points,\n        _p = [],\n        q = [],\n        idx = 0;\n      q[idx++] = p[0];\n      q[idx++] = p[1];\n      q[idx++] = p[2];\n      if (this.order === 3) {\n        q[idx++] = p[3];\n      }\n      // we lerp between all points at each iteration, until we have 1 point left.\n      while (p.length > 1) {\n        _p = [];\n        for (var i = 0, pt, l = p.length - 1; i < l; i++) {\n          pt = utils.lerp(t, p[i], p[i + 1]);\n          q[idx++] = pt;\n          _p.push(pt);\n        }\n        p = _p;\n      }\n      return q;\n    }\n  }, {\n    key: \"split\",\n    value: function split(t1, t2) {\n      // shortcuts\n      if (t1 === 0 && !!t2) {\n        return this.split(t2).left;\n      }\n      if (t2 === 1) {\n        return this.split(t1).right;\n      }\n\n      // no shortcut: use \"de Casteljau\" iteration.\n      var q = this.hull(t1);\n      var result = {\n        left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),\n        right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),\n        span: q\n      };\n\n      // make sure we bind _t1/_t2 information!\n      result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n      result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n      result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n      result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n      // if we have no t2, we're done\n      if (!t2) {\n        return result;\n      }\n\n      // if we have a t2, split again:\n      t2 = utils.map(t2, t1, 1, 0, 1);\n      return result.right.split(t2).left;\n    }\n  }, {\n    key: \"extrema\",\n    value: function extrema() {\n      var result = {};\n      var roots = [];\n      this.dims.forEach(function (dim) {\n        var mfn = function mfn(v) {\n          return v[dim];\n        };\n        var p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this));\n      result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n        return roots.indexOf(v) === idx;\n      });\n      return result;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var extrema = this.extrema(),\n        result = {};\n      this.dims.forEach(function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this));\n      return result;\n    }\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(curve) {\n      var lbbox = this.bbox(),\n        tbbox = curve.bbox();\n      return utils.bboxoverlap(lbbox, tbbox);\n    }\n  }, {\n    key: \"offset\",\n    value: function offset(t, d) {\n      if (typeof d !== \"undefined\") {\n        var c = this.get(t),\n          n = this.normal(t);\n        var ret = {\n          c: c,\n          n: n,\n          x: c.x + n.x * d,\n          y: c.y + n.y * d\n        };\n        if (this._3d) {\n          ret.z = c.z + n.z * d;\n        }\n        return ret;\n      }\n      if (this._linear) {\n        var nv = this.normal(0),\n          coords = this.points.map(function (p) {\n            var ret = {\n              x: p.x + t * nv.x,\n              y: p.y + t * nv.y\n            };\n            if (p.z && nv.z) {\n              ret.z = p.z + t * nv.z;\n            }\n            return ret;\n          });\n        return [new Bezier(coords)];\n      }\n      return this.reduce().map(function (s) {\n        if (s._linear) {\n          return s.offset(t)[0];\n        }\n        return s.scale(t);\n      });\n    }\n  }, {\n    key: \"simple\",\n    value: function simple() {\n      if (this.order === 3) {\n        var a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n        var a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n        if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;\n      }\n      var n1 = this.normal(0);\n      var n2 = this.normal(1);\n      var s = n1.x * n2.x + n1.y * n2.y;\n      if (this._3d) {\n        s += n1.z * n2.z;\n      }\n      return abs(acos(s)) < pi / 3;\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce() {\n      // TODO: examine these var types in more detail...\n      var i,\n        t1 = 0,\n        t2 = 0,\n        step = 0.01,\n        segment,\n        pass1 = [],\n        pass2 = [];\n      // first pass: split on extrema\n      var extrema = this.extrema().values;\n      if (extrema.indexOf(0) === -1) {\n        extrema = [0].concat(extrema);\n      }\n      if (extrema.indexOf(1) === -1) {\n        extrema.push(1);\n      }\n      for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n        t2 = extrema[i];\n        segment = this.split(t1, t2);\n        segment._t1 = t1;\n        segment._t2 = t2;\n        pass1.push(segment);\n        t1 = t2;\n      }\n\n      // second pass: further reduce these segments to simple segments\n      pass1.forEach(function (p1) {\n        t1 = 0;\n        t2 = 0;\n        while (t2 <= 1) {\n          for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n            segment = p1.split(t1, t2);\n            if (!segment.simple()) {\n              t2 -= step;\n              if (abs(t1 - t2) < step) {\n                // we can never form a reduction\n                return [];\n              }\n              segment = p1.split(t1, t2);\n              segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n              segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n              pass2.push(segment);\n              t1 = t2;\n              break;\n            }\n          }\n        }\n        if (t1 < 1) {\n          segment = p1.split(t1, 1);\n          segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n          segment._t2 = p1._t2;\n          pass2.push(segment);\n        }\n      });\n      return pass2;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(v, d1, d2) {\n      d2 = typeof d2 === \"number\" ? d2 : d1;\n\n      // TODO: make this take curves with control points outside\n      //       of the start-end interval into account\n\n      var o = this.order;\n      var d = this.points.map(function (_, i) {\n        return (1 - i / o) * d1 + i / o * d2;\n      });\n      return new Bezier(this.points.map(function (p, i) {\n        return {\n          x: p.x + v.x * d[i],\n          y: p.y + v.y * d[i]\n        };\n      }));\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(d) {\n      var _this = this;\n      var order = this.order;\n      var distanceFn = false;\n      if (typeof d === \"function\") {\n        distanceFn = d;\n      }\n      if (distanceFn && order === 2) {\n        return this.raise().scale(distanceFn);\n      }\n\n      // TODO: add special handling for non-linear degenerate curves.\n\n      var clockwise = this.clockwise;\n      var points = this.points;\n      if (this._linear) {\n        return this.translate(this.normal(0), distanceFn ? distanceFn(0) : d, distanceFn ? distanceFn(1) : d);\n      }\n      var r1 = distanceFn ? distanceFn(0) : d;\n      var r2 = distanceFn ? distanceFn(1) : d;\n      var v = [this.offset(0, 10), this.offset(1, 10)];\n      var np = [];\n      var o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n      if (!o) {\n        throw new Error(\"cannot scale this curve. Try reducing it first.\");\n      }\n\n      // move all points by distance 'd' wrt the origin 'o',\n      // and move end points by fixed distance along normal.\n      [0, 1].forEach(function (t) {\n        var p = np[t * order] = utils.copy(points[t * order]);\n        p.x += (t ? r2 : r1) * v[t].n.x;\n        p.y += (t ? r2 : r1) * v[t].n.y;\n      });\n      if (!distanceFn) {\n        // move control points to lie on the intersection of the offset\n        // derivative vector, and the origin-through-control vector\n        [0, 1].forEach(function (t) {\n          if (order === 2 && !!t) return;\n          var p = np[t * order];\n          var d = _this.derivative(t);\n          var p2 = {\n            x: p.x + d.x,\n            y: p.y + d.y\n          };\n          np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n        });\n        return new Bezier(np);\n      }\n\n      // move control points by \"however much necessary to\n      // ensure the correct tangent to endpoint\".\n      [0, 1].forEach(function (t) {\n        if (order === 2 && !!t) return;\n        var p = points[t + 1];\n        var ov = {\n          x: p.x - o.x,\n          y: p.y - o.y\n        };\n        var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n        if (distanceFn && !clockwise) rc = -rc;\n        var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n        ov.x /= m;\n        ov.y /= m;\n        np[t + 1] = {\n          x: p.x + rc * ov.x,\n          y: p.y + rc * ov.y\n        };\n      });\n      return new Bezier(np);\n    }\n  }, {\n    key: \"outline\",\n    value: function outline(d1, d2, d3, d4) {\n      d2 = d2 === undefined ? d1 : d2;\n      if (this._linear) {\n        // TODO: find the actual extrema, because they might\n        //       be before the start, or past the end.\n\n        var n = this.normal(0);\n        var start = this.points[0];\n        var end = this.points[this.points.length - 1];\n        var s, mid, e;\n        if (d3 === undefined) {\n          d3 = d1;\n          d4 = d2;\n        }\n        s = {\n          x: start.x + n.x * d1,\n          y: start.y + n.y * d1\n        };\n        e = {\n          x: end.x + n.x * d3,\n          y: end.y + n.y * d3\n        };\n        mid = {\n          x: (s.x + e.x) / 2,\n          y: (s.y + e.y) / 2\n        };\n        var fline = [s, mid, e];\n        s = {\n          x: start.x - n.x * d2,\n          y: start.y - n.y * d2\n        };\n        e = {\n          x: end.x - n.x * d4,\n          y: end.y - n.y * d4\n        };\n        mid = {\n          x: (s.x + e.x) / 2,\n          y: (s.y + e.y) / 2\n        };\n        var bline = [e, mid, s];\n        var _ls = utils.makeline(bline[2], fline[0]);\n        var _le = utils.makeline(fline[2], bline[0]);\n        var _segments = [_ls, new Bezier(fline), _le, new Bezier(bline)];\n        return new PolyBezier(_segments);\n      }\n      var reduced = this.reduce(),\n        len = reduced.length,\n        fcurves = [];\n      var bcurves = [],\n        p,\n        alen = 0,\n        tlen = this.length();\n      var graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n      function linearDistanceFunction(s, e, tlen, alen, slen) {\n        return function (v) {\n          var f1 = alen / tlen,\n            f2 = (alen + slen) / tlen,\n            d = e - s;\n          return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n        };\n      }\n\n      // form curve oulines\n      reduced.forEach(function (segment) {\n        var slen = segment.length();\n        if (graduated) {\n          fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));\n          bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));\n        } else {\n          fcurves.push(segment.scale(d1));\n          bcurves.push(segment.scale(-d2));\n        }\n        alen += slen;\n      });\n\n      // reverse the \"return\" outline\n      bcurves = bcurves.map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      }).reverse();\n\n      // form the endcaps as lines\n      var fs = fcurves[0].points[0],\n        fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n        bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n        be = bcurves[0].points[0],\n        ls = utils.makeline(bs, fs),\n        le = utils.makeline(fe, be),\n        segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n      return new PolyBezier(segments);\n    }\n  }, {\n    key: \"outlineshapes\",\n    value: function outlineshapes(d1, d2, curveIntersectionThreshold) {\n      d2 = d2 || d1;\n      var outline = this.outline(d1, d2).curves;\n      var shapes = [];\n      for (var i = 1, len = outline.length; i < len / 2; i++) {\n        var shape = utils.makeshape(outline[i], outline[len - i], curveIntersectionThreshold);\n        shape.startcap.virtual = i > 1;\n        shape.endcap.virtual = i < len / 2 - 1;\n        shapes.push(shape);\n      }\n      return shapes;\n    }\n  }, {\n    key: \"intersects\",\n    value: function intersects(curve, curveIntersectionThreshold) {\n      if (!curve) return this.selfintersects(curveIntersectionThreshold);\n      if (curve.p1 && curve.p2) {\n        return this.lineIntersects(curve);\n      }\n      if (curve instanceof Bezier) {\n        curve = curve.reduce();\n      }\n      return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);\n    }\n  }, {\n    key: \"lineIntersects\",\n    value: function lineIntersects(line) {\n      var _this2 = this;\n      var mx = min(line.p1.x, line.p2.x),\n        my = min(line.p1.y, line.p2.y),\n        MX = max(line.p1.x, line.p2.x),\n        MY = max(line.p1.y, line.p2.y);\n      return utils.roots(this.points, line).filter(function (t) {\n        var p = _this2.get(t);\n        return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n      });\n    }\n  }, {\n    key: \"selfintersects\",\n    value: function selfintersects(curveIntersectionThreshold) {\n      // \"simple\" curves cannot intersect with their direct\n      // neighbour, so for each segment X we check whether\n      // it intersects [0:x-2][x+2:last].\n\n      var reduced = this.reduce(),\n        len = reduced.length - 2,\n        results = [];\n      for (var i = 0, result, left, right; i < len; i++) {\n        left = reduced.slice(i, i + 1);\n        right = reduced.slice(i + 2);\n        result = this.curveintersects(left, right, curveIntersectionThreshold);\n        results.push.apply(results, _toConsumableArray(result));\n      }\n      return results;\n    }\n  }, {\n    key: \"curveintersects\",\n    value: function curveintersects(c1, c2, curveIntersectionThreshold) {\n      var pairs = [];\n      // step 1: pair off any overlapping segments\n      c1.forEach(function (l) {\n        c2.forEach(function (r) {\n          if (l.overlaps(r)) {\n            pairs.push({\n              left: l,\n              right: r\n            });\n          }\n        });\n      });\n      // step 2: for each pairing, run through the convergence algorithm.\n      var intersections = [];\n      pairs.forEach(function (pair) {\n        var result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);\n        if (result.length > 0) {\n          intersections = intersections.concat(result);\n        }\n      });\n      return intersections;\n    }\n  }, {\n    key: \"arcs\",\n    value: function arcs(errorThreshold) {\n      errorThreshold = errorThreshold || 0.5;\n      return this._iterate(errorThreshold, []);\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(pc, np1, s, e) {\n      var q = (e - s) / 4,\n        c1 = this.get(s + q),\n        c2 = this.get(e - q),\n        ref = utils.dist(pc, np1),\n        d1 = utils.dist(pc, c1),\n        d2 = utils.dist(pc, c2);\n      return abs(d1 - ref) + abs(d2 - ref);\n    }\n  }, {\n    key: \"_iterate\",\n    value: function _iterate(errorThreshold, circles) {\n      var t_s = 0,\n        t_e = 1,\n        safety;\n      // we do a binary search to find the \"good `t` closest to no-longer-good\"\n      do {\n        safety = 0;\n\n        // step 1: start with the maximum possible arc\n        t_e = 1;\n\n        // points:\n        var np1 = this.get(t_s),\n          np2 = void 0,\n          np3 = void 0,\n          arc = void 0,\n          prev_arc = void 0;\n\n        // booleans:\n        var curr_good = false,\n          prev_good = false,\n          done = void 0;\n\n        // numbers:\n        var t_m = t_e,\n          prev_e = 1,\n          step = 0;\n\n        // step 2: find the best possible arc\n        do {\n          prev_good = curr_good;\n          prev_arc = arc;\n          t_m = (t_s + t_e) / 2;\n          step++;\n          np2 = this.get(t_m);\n          np3 = this.get(t_e);\n          arc = utils.getccenter(np1, np2, np3);\n\n          //also save the t values\n          arc.interval = {\n            start: t_s,\n            end: t_e\n          };\n          var error = this._error(arc, np1, t_s, t_e);\n          curr_good = error <= errorThreshold;\n          done = prev_good && !curr_good;\n          if (!done) prev_e = t_e;\n\n          // this arc is fine: we can move 'e' up to see if we can find a wider arc\n          if (curr_good) {\n            // if e is already at max, then we're done for this arc.\n            if (t_e >= 1) {\n              // make sure we cap at t=1\n              arc.interval.end = prev_e = 1;\n              prev_arc = arc;\n              // if we capped the arc segment to t=1 we also need to make sure that\n              // the arc's end angle is correct with respect to the bezier end point.\n              if (t_e > 1) {\n                var d = {\n                  x: arc.x + arc.r * cos(arc.e),\n                  y: arc.y + arc.r * sin(arc.e)\n                };\n                arc.e += utils.angle({\n                  x: arc.x,\n                  y: arc.y\n                }, d, this.get(1));\n              }\n              break;\n            }\n            // if not, move it up by half the iteration distance\n            t_e = t_e + (t_e - t_s) / 2;\n          } else {\n            // this is a bad arc: we need to move 'e' down to find a good arc\n            t_e = t_m;\n          }\n        } while (!done && safety++ < 100);\n        if (safety >= 100) {\n          break;\n        }\n\n        // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n        prev_arc = prev_arc ? prev_arc : arc;\n        circles.push(prev_arc);\n        t_s = prev_e;\n      } while (t_e < 1);\n      return circles;\n    }\n  }], [{\n    key: \"quadraticFromPoints\",\n    value: function quadraticFromPoints(p1, p2, p3, t) {\n      if (typeof t === \"undefined\") {\n        t = 0.5;\n      }\n      // shortcuts, although they're really dumb\n      if (t === 0) {\n        return new Bezier(p2, p2, p3);\n      }\n      if (t === 1) {\n        return new Bezier(p1, p2, p2);\n      }\n      // real fitting.\n      var abc = Bezier.getABC(2, p1, p2, p3, t);\n      return new Bezier(p1, abc.A, p3);\n    }\n  }, {\n    key: \"cubicFromPoints\",\n    value: function cubicFromPoints(S, B, E, t, d1) {\n      if (typeof t === \"undefined\") {\n        t = 0.5;\n      }\n      var abc = Bezier.getABC(3, S, B, E, t);\n      if (typeof d1 === \"undefined\") {\n        d1 = utils.dist(B, abc.C);\n      }\n      var d2 = d1 * (1 - t) / t;\n      var selen = utils.dist(S, E),\n        lx = (E.x - S.x) / selen,\n        ly = (E.y - S.y) / selen,\n        bx1 = d1 * lx,\n        by1 = d1 * ly,\n        bx2 = d2 * lx,\n        by2 = d2 * ly;\n      // derivation of new hull coordinates\n      var e1 = {\n          x: B.x - bx1,\n          y: B.y - by1\n        },\n        e2 = {\n          x: B.x + bx2,\n          y: B.y + by2\n        },\n        A = abc.A,\n        v1 = {\n          x: A.x + (e1.x - A.x) / (1 - t),\n          y: A.y + (e1.y - A.y) / (1 - t)\n        },\n        v2 = {\n          x: A.x + (e2.x - A.x) / t,\n          y: A.y + (e2.y - A.y) / t\n        },\n        nc1 = {\n          x: S.x + (v1.x - S.x) / t,\n          y: S.y + (v1.y - S.y) / t\n        },\n        nc2 = {\n          x: E.x + (v2.x - E.x) / (1 - t),\n          y: E.y + (v2.y - E.y) / (1 - t)\n        };\n      // ...done\n      return new Bezier(S, nc1, nc2, E);\n    }\n  }, {\n    key: \"getUtils\",\n    value: function getUtils() {\n      return utils;\n    }\n  }, {\n    key: \"PolyBezier\",\n    get: function get() {\n      return PolyBezier;\n    }\n  }, {\n    key: \"getABC\",\n    value: function getABC() {\n      var order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var S = arguments.length > 1 ? arguments[1] : undefined;\n      var B = arguments.length > 2 ? arguments[2] : undefined;\n      var E = arguments.length > 3 ? arguments[3] : undefined;\n      var t = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n      var u = utils.projectionratio(t, order),\n        um = 1 - u,\n        C = {\n          x: u * S.x + um * E.x,\n          y: u * S.y + um * E.y\n        },\n        s = utils.abcratio(t, order),\n        A = {\n          x: B.x + (B.x - C.x) / s,\n          y: B.y + (B.y - C.y) / s\n        };\n      return {\n        A: A,\n        B: B,\n        C: C,\n        S: S,\n        E: E\n      };\n    }\n  }]);\n  return Bezier;\n}();\nexport { Bezier };","map":{"version":3,"names":["utils","PolyBezier","abs","Math","min","max","cos","sin","acos","sqrt","pi","PI","ZERO","x","y","z","Bezier","coords","_classCallCheck","args","forEach","Array","from","arguments","slice","coordlen","length","newargs","point","d","push","higher","len","Error","_3d","points","idx","step","order","dims","dimlen","aligned","align","p1","p2","baselength","dist","_linear","reduce","t","p","_lut","_t1","_t2","update","_createClass","key","value","getUtils","valueOf","toString","pointsToString","toSVG","s","i","last","join","setRatios","ratios","verify","print","coordDigest","_print","map","c","pos","dpoints","derive","computedirection","angle","clockwise","derivative","bind","getABC","B","get","S","E","getLUT","steps","compute","on","error","lut","hits","project","LUT","l","closest","mpos","t1","t2","mdist","ft","computeWithRatios","raise","np","k","pim","dderivative","curvature","inflections","normal","__normal3","__normal2","q","r1","r2","q1","q2","m","R","n","hull","_p","pt","lerp","split","left","right","result","span","extrema","roots","dim","mfn","v","droots","concat","filter","sort","numberSort","values","indexOf","bbox","getminmax","overlaps","curve","lbbox","tbbox","bboxoverlap","offset","ret","nv","scale","simple","a1","a2","n1","n2","segment","pass1","pass2","translate","d1","d2","o","_","_this","distanceFn","lli4","copy","ov","rc","outline","d3","d4","undefined","start","end","mid","e","fline","bline","ls","makeline","le","segments","reduced","fcurves","bcurves","alen","tlen","graduated","linearDistanceFunction","slen","f1","f2","reverse","fs","fe","bs","be","outlineshapes","curveIntersectionThreshold","curves","shapes","shape","makeshape","startcap","virtual","endcap","intersects","selfintersects","lineIntersects","curveintersects","line","_this2","mx","my","MX","MY","between","results","apply","_toConsumableArray","c1","c2","pairs","r","intersections","pair","pairiteration","arcs","errorThreshold","_iterate","_error","pc","np1","ref","circles","t_s","t_e","safety","np2","np3","arc","prev_arc","curr_good","prev_good","done","t_m","prev_e","getccenter","interval","quadraticFromPoints","p3","abc","A","cubicFromPoints","C","selen","lx","ly","bx1","by1","bx2","by2","e1","e2","v1","v2","nc1","nc2","u","projectionratio","um","abcratio"],"sources":["/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/bezier-js/src/bezier.js"],"sourcesContent":["/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}