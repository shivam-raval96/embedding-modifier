{"ast":null,"code":"/* global CANNON */\n\n/**\n * Kinematic body.\n *\n * Managed dynamic body, which moves but is not affected (directly) by the\n * physics engine. This is not a true kinematic body, in the sense that we are\n * letting the physics engine _compute_ collisions against it and selectively\n * applying those collisions to the object. The physics engine does not decide\n * the position/velocity/rotation of the element.\n *\n * Used for the camera object, because full physics simulation would create\n * movement that feels unnatural to the player. Bipedal movement does not\n * translate nicely to rigid body physics.\n *\n * See: http://www.learn-cocos2d.com/2013/08/physics-engine-platformer-terrible-idea/\n * And: http://oxleygamedev.blogspot.com/2011/04/player-physics-part-2.html\n */\nconst EPS = 0.000001;\nmodule.exports = AFRAME.registerComponent('kinematic-body', {\n  dependencies: ['velocity'],\n  /*******************************************************************\n   * Schema\n   */\n\n  schema: {\n    mass: {\n      default: 5\n    },\n    radius: {\n      default: 1.3\n    },\n    linearDamping: {\n      default: 0.05\n    },\n    enableSlopes: {\n      default: true\n    },\n    enableJumps: {\n      default: false\n    }\n  },\n  /*******************************************************************\n   * Lifecycle\n   */\n\n  init: function () {\n    this.system = this.el.sceneEl.systems.physics;\n    this.system.addComponent(this);\n    const el = this.el,\n      data = this.data,\n      position = new CANNON.Vec3().copy(el.object3D.getWorldPosition(new THREE.Vector3()));\n    this.body = new CANNON.Body({\n      material: this.system.getMaterial('staticMaterial'),\n      position: position,\n      mass: data.mass,\n      linearDamping: data.linearDamping,\n      fixedRotation: true\n    });\n    this.body.addShape(new CANNON.Sphere(data.radius), new CANNON.Vec3(0, data.radius, 0));\n    this.body.el = this.el;\n    this.el.body = this.body;\n    this.system.addBody(this.body);\n    if (el.hasAttribute('wasd-controls')) {\n      console.warn('[kinematic-body] Not compatible with wasd-controls, use movement-controls.');\n    }\n  },\n  remove: function () {\n    this.system.removeBody(this.body);\n    this.system.removeComponent(this);\n    delete this.el.body;\n  },\n  /*******************************************************************\n   * Update\n   */\n\n  /**\n   * Checks CANNON.World for collisions and attempts to apply them to the\n   * element automatically, in a player-friendly way.\n   *\n   * There's extra logic for horizontal surfaces here. The basic requirements:\n   * (1) Only apply gravity when not in contact with _any_ horizontal surface.\n   * (2) When moving, project the velocity against exactly one ground surface.\n   *     If in contact with two ground surfaces (e.g. ground + ramp), choose\n   *     the one that collides with current velocity, if any.\n   */\n  beforeStep: function (t, dt) {\n    if (!dt) return;\n    const el = this.el;\n    const data = this.data;\n    const body = this.body;\n    if (!data.enableJumps) body.velocity.set(0, 0, 0);\n    body.position.copy(el.getAttribute('position'));\n  },\n  step: function () {\n    const velocity = new THREE.Vector3(),\n      normalizedVelocity = new THREE.Vector3(),\n      currentSurfaceNormal = new THREE.Vector3(),\n      groundNormal = new THREE.Vector3();\n    return function (t, dt) {\n      if (!dt) return;\n      let body = this.body,\n        data = this.data,\n        didCollide = false,\n        height,\n        groundHeight = -Infinity,\n        groundBody,\n        contacts = this.system.getContacts();\n      dt = Math.min(dt, this.system.data.maxInterval * 1000);\n      groundNormal.set(0, 0, 0);\n      velocity.copy(this.el.getAttribute('velocity'));\n      body.velocity.copy(velocity);\n      for (var i = 0, contact; contact = contacts[i]; i++) {\n        // 1. Find any collisions involving this element. Get the contact\n        // normal, and make sure it's oriented _out_ of the other object and\n        // enabled (body.collisionReponse is true for both bodies)\n        if (!contact.enabled) {\n          continue;\n        }\n        if (body.id === contact.bi.id) {\n          contact.ni.negate(currentSurfaceNormal);\n        } else if (body.id === contact.bj.id) {\n          currentSurfaceNormal.copy(contact.ni);\n        } else {\n          continue;\n        }\n        didCollide = body.velocity.dot(currentSurfaceNormal) < -EPS;\n        if (didCollide && currentSurfaceNormal.y <= 0.5) {\n          // 2. If current trajectory attempts to move _through_ another\n          // object, project the velocity against the collision plane to\n          // prevent passing through.\n          velocity.projectOnPlane(currentSurfaceNormal);\n        } else if (currentSurfaceNormal.y > 0.5) {\n          // 3. If in contact with something roughly horizontal (+/- 45ยบ) then\n          // consider that the current ground. Only the highest qualifying\n          // ground is retained.\n          height = body.id === contact.bi.id ? Math.abs(contact.rj.y + contact.bj.position.y) : Math.abs(contact.ri.y + contact.bi.position.y);\n          if (height > groundHeight) {\n            groundHeight = height;\n            groundNormal.copy(currentSurfaceNormal);\n            groundBody = body.id === contact.bi.id ? contact.bj : contact.bi;\n          }\n        }\n      }\n      normalizedVelocity.copy(velocity).normalize();\n      if (groundBody && (!data.enableJumps || normalizedVelocity.y < 0.5)) {\n        if (!data.enableSlopes) {\n          groundNormal.set(0, 1, 0);\n        } else if (groundNormal.y < 1 - EPS) {\n          groundNormal.copy(this.raycastToGround(groundBody, groundNormal));\n        }\n\n        // 4. Project trajectory onto the top-most ground object, unless\n        // trajectory is > 45ยบ.\n        velocity.projectOnPlane(groundNormal);\n      } else if (this.system.driver.world) {\n        // 5. If not in contact with anything horizontal, apply world gravity.\n        // TODO - Why is the 4x scalar necessary.\n        // NOTE: Does not work if physics runs on a worker.\n        velocity.add(this.system.driver.world.gravity.scale(dt * 4.0 / 1000));\n      }\n      body.velocity.copy(velocity);\n      this.el.setAttribute('velocity', body.velocity);\n      this.el.setAttribute('position', body.position);\n    };\n  }(),\n  /**\n   * When walking on complex surfaces (trimeshes, borders between two shapes),\n   * the collision normals returned for the player sphere can be very\n   * inconsistent. To address this, raycast straight down, find the collision\n   * normal, and return whichever normal is more vertical.\n   * @param  {CANNON.Body} groundBody\n   * @param  {CANNON.Vec3} groundNormal\n   * @return {CANNON.Vec3}\n   */\n  raycastToGround: function (groundBody, groundNormal) {\n    let ray,\n      hitNormal,\n      vFrom = this.body.position,\n      vTo = this.body.position.clone();\n    ray = new CANNON.Ray(vFrom, vTo);\n    ray._updateDirection(); // TODO - Report bug.\n    ray.intersectBody(groundBody);\n    if (!ray.hasHit) return groundNormal;\n\n    // Compare ABS, in case we're projecting against the inside of the face.\n    hitNormal = ray.result.hitNormalWorld;\n    return Math.abs(hitNormal.y) > Math.abs(groundNormal.y) ? hitNormal : groundNormal;\n  }\n});","map":{"version":3,"names":["EPS","module","exports","AFRAME","registerComponent","dependencies","schema","mass","default","radius","linearDamping","enableSlopes","enableJumps","init","system","el","sceneEl","systems","physics","addComponent","data","position","CANNON","Vec3","copy","object3D","getWorldPosition","THREE","Vector3","body","Body","material","getMaterial","fixedRotation","addShape","Sphere","addBody","hasAttribute","console","warn","remove","removeBody","removeComponent","beforeStep","t","dt","velocity","set","getAttribute","step","normalizedVelocity","currentSurfaceNormal","groundNormal","didCollide","height","groundHeight","Infinity","groundBody","contacts","getContacts","Math","min","maxInterval","i","contact","enabled","id","bi","ni","negate","bj","dot","y","projectOnPlane","abs","rj","ri","normalize","raycastToGround","driver","world","add","gravity","scale","setAttribute","ray","hitNormal","vFrom","vTo","clone","Ray","_updateDirection","intersectBody","hasHit","result","hitNormalWorld"],"sources":["/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/aframe-extras/src/misc/kinematic-body.js"],"sourcesContent":["/* global CANNON */\n\n/**\n * Kinematic body.\n *\n * Managed dynamic body, which moves but is not affected (directly) by the\n * physics engine. This is not a true kinematic body, in the sense that we are\n * letting the physics engine _compute_ collisions against it and selectively\n * applying those collisions to the object. The physics engine does not decide\n * the position/velocity/rotation of the element.\n *\n * Used for the camera object, because full physics simulation would create\n * movement that feels unnatural to the player. Bipedal movement does not\n * translate nicely to rigid body physics.\n *\n * See: http://www.learn-cocos2d.com/2013/08/physics-engine-platformer-terrible-idea/\n * And: http://oxleygamedev.blogspot.com/2011/04/player-physics-part-2.html\n */\nconst EPS = 0.000001;\n\nmodule.exports = AFRAME.registerComponent('kinematic-body', {\n  dependencies: ['velocity'],\n\n  /*******************************************************************\n   * Schema\n   */\n\n  schema: {\n    mass:           { default: 5 },\n    radius:         { default: 1.3 },\n    linearDamping:  { default: 0.05 },\n    enableSlopes:   { default: true },\n    enableJumps:    { default: false },\n  },\n\n  /*******************************************************************\n   * Lifecycle\n   */\n\n  init: function () {\n    this.system = this.el.sceneEl.systems.physics;\n    this.system.addComponent(this);\n\n    const el = this.el,\n        data = this.data,\n        position = (new CANNON.Vec3()).copy(el.object3D.getWorldPosition(new THREE.Vector3()));\n\n    this.body = new CANNON.Body({\n      material: this.system.getMaterial('staticMaterial'),\n      position: position,\n      mass: data.mass,\n      linearDamping: data.linearDamping,\n      fixedRotation: true\n    });\n    this.body.addShape(\n      new CANNON.Sphere(data.radius),\n      new CANNON.Vec3(0, data.radius, 0)\n    );\n\n    this.body.el = this.el;\n    this.el.body = this.body;\n    this.system.addBody(this.body);\n\n    if (el.hasAttribute('wasd-controls')) {\n      console.warn('[kinematic-body] Not compatible with wasd-controls, use movement-controls.');\n    }\n  },\n\n  remove: function () {\n    this.system.removeBody(this.body);\n    this.system.removeComponent(this);\n    delete this.el.body;\n  },\n\n  /*******************************************************************\n   * Update\n   */\n\n  /**\n   * Checks CANNON.World for collisions and attempts to apply them to the\n   * element automatically, in a player-friendly way.\n   *\n   * There's extra logic for horizontal surfaces here. The basic requirements:\n   * (1) Only apply gravity when not in contact with _any_ horizontal surface.\n   * (2) When moving, project the velocity against exactly one ground surface.\n   *     If in contact with two ground surfaces (e.g. ground + ramp), choose\n   *     the one that collides with current velocity, if any.\n   */\n  beforeStep: function (t, dt) {\n    if (!dt) return;\n\n    const el = this.el;\n    const data = this.data\n    const body = this.body;\n\n    if (!data.enableJumps) body.velocity.set(0, 0, 0);\n    body.position.copy(el.getAttribute('position'));\n  },\n\n  step: (function () {\n    const velocity = new THREE.Vector3(),\n        normalizedVelocity = new THREE.Vector3(),\n        currentSurfaceNormal = new THREE.Vector3(),\n        groundNormal = new THREE.Vector3();\n\n    return function (t, dt) {\n      if (!dt) return;\n\n      let body = this.body,\n          data = this.data,\n          didCollide = false,\n          height, groundHeight = -Infinity,\n          groundBody,\n          contacts = this.system.getContacts();\n\n      dt = Math.min(dt, this.system.data.maxInterval * 1000);\n\n      groundNormal.set(0, 0, 0);\n      velocity.copy(this.el.getAttribute('velocity'));\n      body.velocity.copy(velocity);\n\n      for (var i = 0, contact; contact = contacts[i]; i++) {\n        // 1. Find any collisions involving this element. Get the contact\n        // normal, and make sure it's oriented _out_ of the other object and\n        // enabled (body.collisionReponse is true for both bodies)\n        if (!contact.enabled) { continue; }\n        if (body.id === contact.bi.id) {\n          contact.ni.negate(currentSurfaceNormal);\n        } else if (body.id === contact.bj.id) {\n          currentSurfaceNormal.copy(contact.ni);\n        } else {\n          continue;\n        }\n\n        didCollide = body.velocity.dot(currentSurfaceNormal) < -EPS;\n        if (didCollide && currentSurfaceNormal.y <= 0.5) {\n          // 2. If current trajectory attempts to move _through_ another\n          // object, project the velocity against the collision plane to\n          // prevent passing through.\n          velocity.projectOnPlane(currentSurfaceNormal);\n        } else if (currentSurfaceNormal.y > 0.5) {\n          // 3. If in contact with something roughly horizontal (+/- 45ยบ) then\n          // consider that the current ground. Only the highest qualifying\n          // ground is retained.\n          height = body.id === contact.bi.id\n            ? Math.abs(contact.rj.y + contact.bj.position.y)\n            : Math.abs(contact.ri.y + contact.bi.position.y);\n          if (height > groundHeight) {\n            groundHeight = height;\n            groundNormal.copy(currentSurfaceNormal);\n            groundBody = body.id === contact.bi.id ? contact.bj : contact.bi;\n          }\n        }\n      }\n\n      normalizedVelocity.copy(velocity).normalize();\n      if (groundBody && (!data.enableJumps || normalizedVelocity.y < 0.5)) {\n        if (!data.enableSlopes) {\n          groundNormal.set(0, 1, 0);\n        } else if (groundNormal.y < 1 - EPS) {\n          groundNormal.copy(this.raycastToGround(groundBody, groundNormal));\n        }\n\n        // 4. Project trajectory onto the top-most ground object, unless\n        // trajectory is > 45ยบ.\n        velocity.projectOnPlane(groundNormal);\n\n      } else if (this.system.driver.world) {\n        // 5. If not in contact with anything horizontal, apply world gravity.\n        // TODO - Why is the 4x scalar necessary.\n        // NOTE: Does not work if physics runs on a worker.\n        velocity.add(this.system.driver.world.gravity.scale(dt * 4.0 / 1000));\n      }\n\n      body.velocity.copy(velocity);\n      this.el.setAttribute('velocity', body.velocity);\n      this.el.setAttribute('position', body.position);\n    };\n  }()),\n\n  /**\n   * When walking on complex surfaces (trimeshes, borders between two shapes),\n   * the collision normals returned for the player sphere can be very\n   * inconsistent. To address this, raycast straight down, find the collision\n   * normal, and return whichever normal is more vertical.\n   * @param  {CANNON.Body} groundBody\n   * @param  {CANNON.Vec3} groundNormal\n   * @return {CANNON.Vec3}\n   */\n  raycastToGround: function (groundBody, groundNormal) {\n    let ray,\n        hitNormal,\n        vFrom = this.body.position,\n        vTo = this.body.position.clone();\n\n    ray = new CANNON.Ray(vFrom, vTo);\n    ray._updateDirection(); // TODO - Report bug.\n    ray.intersectBody(groundBody);\n\n    if (!ray.hasHit) return groundNormal;\n\n    // Compare ABS, in case we're projecting against the inside of the face.\n    hitNormal = ray.result.hitNormalWorld;\n    return Math.abs(hitNormal.y) > Math.abs(groundNormal.y) ? hitNormal : groundNormal;\n  }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}