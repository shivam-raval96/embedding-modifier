{"ast":null,"code":"import * as d3 from 'd3';\n// import { trackPointer } from \"@fil/pointer-events\"\n\nfunction trackPointer(e, {\n  start,\n  move,\n  out,\n  end\n}) {\n  //from https://observablehq.com/@fil/pointer-events#trackPointer\n  const tracker = {},\n    id = tracker.id = e.pointerId,\n    target = e.target;\n  tracker.point = d3.pointer(e, target);\n  target.setPointerCapture(id);\n  d3.select(target).on(`pointerup.${id} pointercancel.${id} lostpointercapture.${id}`, e => {\n    if (e.pointerId !== id) return;\n    tracker.sourceEvent = e;\n    d3.select(target).on(`.${id}`, null);\n    target.releasePointerCapture(id);\n    end && end(tracker);\n  }).on(`pointermove.${id}`, e => {\n    if (e.pointerId !== id) return;\n    tracker.sourceEvent = e;\n    tracker.prev = tracker.point;\n    tracker.point = d3.pointer(e, target);\n    move && move(tracker);\n  }).on(`pointerout.${id}`, e => {\n    if (e.pointerId !== id) return;\n    tracker.sourceEvent = e;\n    tracker.point = null;\n    out && out(tracker);\n  });\n  start && start(tracker);\n}\nexport default function lasso() {\n  // from https://observablehq.com/@fil/lasso-selection\n  const dispatch = d3.dispatch(\"start\", \"lasso\", \"end\");\n  const lasso = function (selection) {\n    const node = selection.node();\n    const polygon = [];\n    selection.on(\"touchmove\", e => e.preventDefault()) // prevent scrolling\n    .on(\"pointerdown\", e => {\n      trackPointer(e, {\n        start: p => {\n          polygon.length = 0;\n          dispatch.call(\"start\", node, polygon);\n        },\n        move: p => {\n          polygon.push(p.point);\n          dispatch.call(\"lasso\", node, polygon);\n        },\n        end: p => {\n          dispatch.call(\"end\", node, polygon);\n        }\n      });\n    });\n  };\n  lasso.on = function (type, _) {\n    return _ ? (dispatch.on(...arguments), lasso) : dispatch.on(...arguments);\n  };\n  return lasso;\n}\n\n// import * as d3 from 'd3'\n// //version2 https://github.com/skokenes/D3-Lasso-Plugin/blob/master/lasso.js\n// d3.lasso = function () {\n\n//   var items = null,\n//     closePathDistance = 75,\n//     closePathSelect = true,\n//     isPathClosed = false,\n//     hoverSelect = true,\n//     points = [],\n//     area = null,\n//     on = { start: function () { }, draw: function () { }, end: function () { } };\n\n//   function lasso() {\n//     // the element where the lasso was called\n//     var _this = d3.select(this[0][0]);\n\n//     // add a new group for the lasso\n//     var g = _this.append(\"g\")\n//       .attr(\"class\", \"lasso\");\n\n//     // add the drawn path for the lasso\n//     var dyn_path = g.append(\"path\")\n//       .attr(\"class\", \"drawn\");\n\n//     // add a path used for calculations\n//     var calc_path = g.append(\"path\")\n//       .attr(\"display\", \"none\");\n\n//     // add a closed path\n//     var close_path = g.append(\"path\")\n//       .attr(\"class\", \"loop_close\");\n\n//     // add a close path used for calculations\n//     var calc_close_path = g.append(\"path\")\n//       .attr(\"display\", \"none\");\n\n//     // add an origin node\n//     var origin_node = g.append(\"circle\")\n//       .attr(\"class\", \"origin\");\n\n//     // The lasso path for calculations\n//     var path;\n\n//     // The transformed lasso path for rendering\n//     var tpath;\n\n//     // The lasso origin for calculations\n//     var origin;\n\n//     // The transformed lasso origin for rendering\n//     var torigin;\n\n//     // The last known point on the lasso during drag - needed for evaluating edges\n//     var last_known_point;\n\n//     // The starting point for evaluating the path\n//     var path_length_start;\n\n//     // Apply drag behaviors\n//     var drag = d3.behavior.drag()\n//       .on(\"dragstart\", dragstart)\n//       .on(\"drag\", dragmove)\n//       .on(\"dragend\", dragend);\n\n//     // Call drag\n//     area.call(drag);\n\n//     function dragstart() {\n//       // Initialize paths\n//       path = \"\";\n//       tpath = \"\";\n//       dyn_path.attr(\"d\", null);\n//       close_path.attr(\"d\", null);\n\n//       // Set path length start\n//       path_length_start = 0;\n\n//       // Set every item to have a false selection and reset their center point and counters\n//       items[0].forEach(function (d) {\n//         d.hoverSelected = false;\n//         d.loopSelected = false;\n//         var box = d.getBoundingClientRect();\n//         d.lassoPoint = {\n//           cx: Math.round(box.left + box.width / 2),\n//           cy: Math.round(box.top + box.height / 2),\n//           edges: { top: 0, right: 0, bottom: 0, left: 0 },\n//           close_edges: { left: 0, right: 0 }\n//         };\n\n//       });\n\n//       // if hover is on, add hover function\n//       if (hoverSelect === true) {\n//         items.on(\"mouseover.lasso\", function () {\n//           // if hovered, change lasso selection attribute to true\n//           d3.select(this)[0][0].hoverSelected = true;\n//         });\n//       }\n\n//       // Run user defined start function\n//       on.start();\n//     }\n\n//     function dragmove() {\n//       // Get mouse position within body, used for calculations\n//       var x = d3.event.sourceEvent.clientX;\n//       var y = d3.event.sourceEvent.clientY;\n//       // Get mouse position within drawing area, used for rendering\n//       var tx = d3.mouse(this)[0];\n//       var ty = d3.mouse(this)[1];\n\n//       // Initialize the path or add the latest point to it\n//       if (path === \"\") {\n//         path = path + \"M \" + x + \" \" + y;\n//         tpath = tpath + \"M \" + tx + \" \" + ty;\n//         origin = [x, y];\n//         torigin = [tx, ty];\n//         // Draw origin node\n//         origin_node\n//           .attr(\"cx\", tx)\n//           .attr(\"cy\", ty)\n//           .attr(\"r\", 7)\n//           .attr(\"display\", null);\n//       }\n//       else {\n//         path = path + \" L \" + x + \" \" + y;\n//         tpath = tpath + \" L \" + tx + \" \" + ty;\n//       }\n\n//       // Reset closed edges counter\n//       items[0].forEach(function (d) {\n//         d.lassoPoint.close_edges = { left: 0, right: 0 };\n//       });\n\n//       // Calculate the current distance from the lasso origin\n//       var distance = Math.sqrt(Math.pow(x - origin[0], 2) + Math.pow(y - origin[1], 2));\n\n//       // Set the closed path line\n//       var close_draw_path = \"M \" + tx + \" \" + ty + \" L \" + torigin[0] + \" \" + torigin[1];\n\n//       // Set the calc closed path line\n//       var calc_close_draw_path = \"M \" + x + \" \" + y + \" L \" + origin[0] + \" \" + origin[1];\n\n//       // Draw the lines\n//       dyn_path.attr(\"d\", tpath);\n\n//       // path for calcs\n//       calc_path.attr(\"d\", path);\n\n//       calc_close_path.attr(\"d\", calc_close_draw_path);\n\n//       // Check if the path is closed\n//       isPathClosed = distance <= closePathDistance ? true : false;\n\n//       // If within the closed path distance parameter, show the closed path. otherwise, hide it\n//       if (isPathClosed) {\n//         close_path.attr(\"display\", null);\n//       }\n//       else {\n//         close_path.attr(\"display\", \"none\");\n//       }\n\n//       // Get path length\n//       var path_node = calc_path.node();\n//       var path_length_end = path_node.getTotalLength();\n//       // Get the ending point of the path\n//       var last_pos = path_node.getPointAtLength(path_length_start - 1);\n\n//       // Iterate through each point on the path\n//       for (var i = path_length_start; i <= path_length_end; i++) {\n//         // Get the current coordinates on the path\n//         var cur_pos = path_node.getPointAtLength(i);\n//         var cur_pos_obj = {\n//           x: Math.round(cur_pos.x * 100) / 100,\n//           y: Math.round(cur_pos.y * 100) / 100,\n//         };\n//         // Get the prior coordinates on the path\n//         var prior_pos = path_node.getPointAtLength(i - 1);\n//         var prior_pos_obj = {\n//           x: Math.round(prior_pos.x * 100) / 100,\n//           y: Math.round(prior_pos.y * 100) / 100,\n//         };\n\n//         // Iterate through each item\n//         items[0].filter(function (d) {\n//           var a;\n//           // If we are on the same y position as the item and we weren't on this y before,\n//           // mark as the last known point. Return false - we don't need to count an edge yet\n//           if (d.lassoPoint.cy === cur_pos_obj.y && d.lassoPoint.cy != prior_pos_obj.y) {\n//             last_known_point = {\n//               x: prior_pos_obj.x,\n//               y: prior_pos_obj.y\n//             };\n//             a = false;\n//           }\n//           // If we are on the same y position as the item and we were on this y before,\n//           // return false - we don't need to count an edge yet\n//           else if (d.lassoPoint.cy === cur_pos_obj.y && d.lassoPoint.cy === prior_pos_obj.y) {\n//             a = false;\n//           }\n//           // If we are not on the same y position as the item but we were previously,\n//           // determine if we passed by the item or came up to it and turned around.\n//           // Return true if we passed it so that we can evaluate for an edge\n//           else if (d.lassoPoint.cy != cur_pos_obj.y && d.lassoPoint.cy === prior_pos_obj.y) {\n//             a = sign(d.lassoPoint.cy - cur_pos_obj.y) != sign(d.lassoPoint.cy - last_known_point.y);\n//           }\n//           // Else, mark a last known point and check for a crossing.\n//           // If we crossed, we need to evaluate for edges\n//           else {\n//             last_known_point = {\n//               x: prior_pos_obj.x,\n//               y: prior_pos_obj.y\n//             };\n//             a = sign(d.lassoPoint.cy - cur_pos_obj.y) != sign(d.lassoPoint.cy - prior_pos_obj.y);\n//           }\n//           return a;\n//         }).forEach(function (d) {\n//           // Iterate through each object and add an edge to the left or right\n//           if (cur_pos_obj.x > d.lassoPoint.cx) {\n//             d.lassoPoint.edges.right = d.lassoPoint.edges.right + 1;\n//           }\n//           if (cur_pos_obj.x < d.lassoPoint.cx) {\n//             d.lassoPoint.edges.left = d.lassoPoint.edges.left + 1;\n//           }\n//         });\n//       }\n\n//       // If the path is closed and close select is set to true, draw the closed paths and count edges\n//       if (isPathClosed === true && closePathSelect === true) {\n//         close_path.attr(\"d\", close_draw_path);\n//         var close_path_node = calc_close_path.node();\n//         var close_path_length = close_path_node.getTotalLength();\n//         var close_path_edges = { left: 0, right: 0 };\n//         for (var i = 0; i <= close_path_length; i++) {\n//           var cur_pos = close_path_node.getPointAtLength(i);\n//           var prior_pos = close_path_node.getPointAtLength(i - 1);\n\n//           items[0].filter(function (d) { return d.lassoPoint.cy == Math.round(cur_pos.y); }).forEach(function (d) {\n//             if (Math.round(cur_pos.y) != Math.round(prior_pos.y) && Math.round(cur_pos.x) > d.lassoPoint.cx) {\n//               d.lassoPoint.close_edges.right = 1;\n//             }\n//             if (Math.round(cur_pos.y) != Math.round(prior_pos.y) && Math.round(cur_pos.x) < d.lassoPoint.cx) {\n//               d.lassoPoint.close_edges.left = 1;\n//             }\n//           });\n\n//         }\n\n//         // Check and see if the points have at least one edge to the left, and an odd # of edges to the right. If so, mark as selected.\n//         items[0].forEach(function (a) {\n//           if ((a.lassoPoint.edges.left + a.lassoPoint.close_edges.left) > 0 && (a.lassoPoint.edges.right + a.lassoPoint.close_edges.right) % 2 == 1) {\n//             a.loopSelected = true;\n//           }\n//           else {\n//             a.loopSelected = false;\n//           }\n//         });\n//       }\n//       else {\n//         items[0].forEach(function (d) {\n//           d.loopSelected = false;\n//         });\n//       }\n\n//       // Tag possible items\n//       d3.selectAll(items[0].filter(function (d) { return (d.loopSelected && isPathClosed) || d.hoverSelected; }))\n//         .each(function (d) { d.possible = true; });\n\n//       d3.selectAll(items[0].filter(function (d) { return !((d.loopSelected && isPathClosed) || d.hoverSelected); }))\n//         .each(function (d) { d.possible = false; });\n\n//       on.draw();\n\n//       // Continue drawing path from where it left off\n//       path_length_start = path_length_end + 1;\n//     }\n\n//     function dragend() {\n//       // Remove mouseover tagging function\n//       items.on(\"mouseover.lasso\", null);\n\n//       // Tag selected items\n//       items.filter(function (d) { return d.possible === true; })\n//         .each(function (d) { d.selected = true; });\n\n//       items.filter(function (d) { return d.possible === false; })\n//         .each(function (d) { d.selected = false; });\n\n//       // Reset possible items\n//       items\n//         .each(function (d) { d.possible = false; });\n\n//       // Clear lasso\n//       dyn_path.attr(\"d\", null);\n//       close_path.attr(\"d\", null);\n//       origin_node.attr(\"display\", \"none\");\n\n//       // Run user defined end function\n//       on.end();\n\n//     }\n//   }\n\n//   lasso.items = function (_) {\n\n//     if (!arguments.length) return items;\n//     items = _;\n//     items[0].forEach(function (d) {\n//       var item = d3.select(d);\n//       if (typeof item.datum() === 'undefined') {\n//         item.datum({ possible: false, selected: false });\n//       }\n//       else {\n//         //item.attr(\"d\",function(e) {e.possible = false; e.selected = false; return e;});\n//         var e = item.datum();\n//         e.possible = false;\n//         e.selected = false;\n//         item.datum(e);\n//       }\n//     });\n//     return lasso;\n//   };\n\n//   lasso.closePathDistance = function (_) {\n//     if (!arguments.length) return closePathDistance;\n//     closePathDistance = _;\n//     return lasso;\n//   };\n\n//   lasso.closePathSelect = function (_) {\n//     if (!arguments.length) return closePathSelect;\n//     closePathSelect = _ === true ? true : false;\n//     return lasso;\n//   };\n\n//   lasso.isPathClosed = function (_) {\n//     if (!arguments.length) return isPathClosed;\n//     isPathClosed = _ === true ? true : false;\n//     return lasso;\n//   };\n\n//   lasso.hoverSelect = function (_) {\n//     if (!arguments.length) return hoverSelect;\n//     hoverSelect = _ === true ? true : false;\n//     return lasso;\n//   };\n\n//   lasso.on = function (type, _) {\n//     if (!arguments.length) return on;\n//     if (arguments.length === 1) return on[type];\n//     var types = [\"start\", \"draw\", \"end\"];\n//     if (types.indexOf(type) > -1) {\n//       on[type] = _;\n//     }\n//     return lasso;\n//   };\n\n//   lasso.area = function (_) {\n//     if (!arguments.length) return area;\n//     area = _;\n//     return lasso;\n//   };\n\n//   function sign(x) {\n//     return x ? x < 0 ? -1 : 1 : 0;\n//   }\n\n//   return lasso;\n\n// };\n// //---version1 https://github.com/skokenes/d3-lasso/blob/master/src/lasso.js\n// // import * as selection from \"d3-selection\";\n// // import * as d3 from \"d3\"\n// // import * as drag from \"d3-drag\";\n// // import classifyPoint from \"robust-point-in-polygon\";\n\n// // export default function () {\n\n// //   var items = [],\n// //     closePathDistance = 75,\n// //     closePathSelect = true,\n// //     isPathClosed = false,\n// //     hoverSelect = true,\n// //     targetArea,\n// //     on = { start: function () { }, draw: function () { }, end: function () { } };\n\n// //   // Function to execute on call\n// //   function lasso(_this) {\n\n// //     // add a new group for the lasso\n// //     var g = _this.append(\"g\")\n// //       .attr(\"class\", \"lasso\");\n\n// //     // add the drawn path for the lasso\n// //     var dyn_path = g.append(\"path\")\n// //       .attr(\"class\", \"drawn\");\n\n// //     // add a closed path\n// //     var close_path = g.append(\"path\")\n// //       .attr(\"class\", \"loop_close\");\n\n// //     // add an origin node\n// //     var origin_node = g.append(\"circle\")\n// //       .attr(\"class\", \"origin\");\n\n// //     // The transformed lasso path for rendering\n// //     var tpath;\n\n// //     // The lasso origin for calculations\n// //     var origin;\n\n// //     // The transformed lasso origin for rendering\n// //     var torigin;\n\n// //     // Store off coordinates drawn\n// //     var drawnCoords;\n\n// //     // Apply drag behaviors\n// //     var dragAction = drag.drag()\n// //       .on(\"start\", dragstart)\n// //       .on(\"drag\", dragmove)\n// //       .on(\"end\", dragend);\n\n// //     // Call drag\n// //     targetArea.call(dragAction);\n\n// //     function dragstart() {\n// //       // Init coordinates\n// //       drawnCoords = [];\n\n// //       // Initialize paths\n// //       tpath = \"\";\n// //       dyn_path.attr(\"d\", null);\n// //       close_path.attr(\"d\", null);\n\n// //       // Set every item to have a false selection and reset their center point and counters\n// //       items.nodes().forEach(function (e) {\n// //         e.__lasso.possible = false;\n// //         e.__lasso.selected = false;\n// //         e.__lasso.hoverSelect = false;\n// //         e.__lasso.loopSelect = false;\n\n// //         var box = e.getBoundingClientRect();\n// //         e.__lasso.lassoPoint = [Math.round(box.left + box.width / 2), Math.round(box.top + box.height / 2)];\n// //       });\n\n// //       // if hover is on, add hover function\n// //       if (hoverSelect) {\n// //         items.on(\"mouseover.lasso\", function () {\n// //           // if hovered, change lasso selection attribute to true\n// //           this.__lasso.hoverSelect = true;\n// //         });\n// //       }\n\n// //       // Run user defined start function\n// //       on.start();\n// //     }\n\n// //     function dragmove(event) {\n// //       // Get mouse position within body, used for calculations\n// //       var x, y;\n// //       if (event.type === \"touchmove\") {\n// //         x = event.touches[0].clientX;\n// //         y = event.touches[0].clientY;\n// //       } else {\n// //         x = event.clientX;\n// //         y = event.clientY;\n// //       }\n\n// //       // Get mouse position within drawing area, used for rendering\n// //       var tx = d3.pointer(event, this)[0];\n// //       var ty = d3.pointer(event, this)[1];\n\n// //       // Initialize the path or add the latest point to it\n// //       if (tpath === \"\") {\n// //         tpath = tpath + \"M \" + tx + \" \" + ty;\n// //         origin = [x, y];\n// //         torigin = [tx, ty];\n// //         // Draw origin node\n// //         origin_node\n// //           .attr(\"cx\", tx)\n// //           .attr(\"cy\", ty)\n// //           .attr(\"r\", 7)\n// //           .attr(\"display\", null);\n// //       } else {\n// //         tpath = tpath + \" L \" + tx + \" \" + ty;\n// //       }\n\n// //       drawnCoords.push([x, y]);\n\n// //       // Calculate the current distance from the lasso origin\n// //       var distance = Math.sqrt(Math.pow(x - origin[0], 2) + Math.pow(y - origin[1], 2));\n\n// //       // Set the closed path line\n// //       var close_draw_path = \"M \" + tx + \" \" + ty + \" L \" + torigin[0] + \" \" + torigin[1];\n\n// //       // Draw the lines\n// //       dyn_path.attr(\"d\", tpath);\n\n// //       close_path.attr(\"d\", close_draw_path);\n\n// //       // Check if the path is closed\n// //       isPathClosed = distance <= closePathDistance ? true : false;\n\n// //       // If within the closed path distance parameter, show the closed path. otherwise, hide it\n// //       if (isPathClosed && closePathSelect) {\n// //         close_path.attr(\"display\", null);\n// //       } else {\n// //         close_path.attr(\"display\", \"none\");\n// //       }\n\n// //       items.nodes().forEach(function (n) {\n// //         n.__lasso.loopSelect = isPathClosed && closePathSelect ? classifyPoint(drawnCoords, n.__lasso.lassoPoint) < 1 : false;\n// //         n.__lasso.possible = n.__lasso.hoverSelect || n.__lasso.loopSelect;\n// //       });\n\n// //       on.draw();\n// //     }\n\n// //     // function dragmove() {\n// //     //     // Get mouse position within body, used for calculations\n// //     //     var x,y;\n// //     //     if(selection.event.sourceEvent.type === \"touchmove\") {\n// //     //         x = selection.event.sourceEvent.touches[0].clientX;\n// //     //         y = selection.event.sourceEvent.touches[0].clientY;\n// //     //     }\n// //     //     else {\n// //     //         x = selection.event.sourceEvent.clientX;\n// //     //         y = selection.event.sourceEvent.clientY;\n// //     //     }\n\n// //     //     // Get mouse position within drawing area, used for rendering\n// //     //     var tx = selection.mouse(this)[0];\n// //     //     var ty = selection.mouse(this)[1];\n\n// //     //     // Initialize the path or add the latest point to it\n// //     //     if (tpath===\"\") {\n// //     //         tpath = tpath + \"M \" + tx + \" \" + ty;\n// //     //         origin = [x,y];\n// //     //         torigin = [tx,ty];\n// //     //         // Draw origin node\n// //     //         origin_node\n// //     //             .attr(\"cx\",tx)\n// //     //             .attr(\"cy\",ty)\n// //     //             .attr(\"r\",7)\n// //     //             .attr(\"display\",null);\n// //     //     }\n// //     //     else {\n// //     //         tpath = tpath + \" L \" + tx + \" \" + ty;\n// //     //     }\n\n// //     //     drawnCoords.push([x,y]);\n\n// //     //     // Calculate the current distance from the lasso origin\n// //     //     var distance = Math.sqrt(Math.pow(x-origin[0],2)+Math.pow(y-origin[1],2));\n\n// //     //     // Set the closed path line\n// //     //     var close_draw_path = \"M \" + tx + \" \" + ty + \" L \" + torigin[0] + \" \" + torigin[1];\n\n// //     //     // Draw the lines\n// //     //     dyn_path.attr(\"d\",tpath);\n\n// //     //     close_path.attr(\"d\",close_draw_path);\n\n// //     //     // Check if the path is closed\n// //     //     isPathClosed = distance<=closePathDistance ? true : false;\n\n// //     //     // If within the closed path distance parameter, show the closed path. otherwise, hide it\n// //     //     if(isPathClosed && closePathSelect) {\n// //     //         close_path.attr(\"display\",null);\n// //     //     }\n// //     //     else {\n// //     //         close_path.attr(\"display\",\"none\");\n// //     //     }\n\n// //     //     items.nodes().forEach(function(n) {\n// //     //         n.__lasso.loopSelect = (isPathClosed && closePathSelect) ? (classifyPoint(drawnCoords,n.__lasso.lassoPoint) < 1) : false; \n// //     //         n.__lasso.possible = n.__lasso.hoverSelect || n.__lasso.loopSelect; \n// //     //     });\n\n// //     //     on.draw();\n// //     // }\n\n// //     function dragend() {\n// //       // Remove mouseover tagging function\n// //       items.on(\"mouseover.lasso\", null);\n\n// //       items.nodes().forEach(function (n) {\n// //         n.__lasso.selected = n.__lasso.possible;\n// //         n.__lasso.possible = false;\n// //       });\n\n// //       // Clear lasso\n// //       dyn_path.attr(\"d\", null);\n// //       close_path.attr(\"d\", null);\n// //       origin_node.attr(\"display\", \"none\");\n\n// //       // Run user defined end function\n// //       on.end();\n// //     }\n// //   }\n\n// //   // Set or get list of items for lasso to select\n// //   lasso.items = function (_) {\n// //     if (!arguments.length) return items;\n// //     items = _;\n// //     var nodes = items.nodes();\n// //     nodes.forEach(function (n) {\n// //       n.__lasso = {\n// //         \"possible\": false,\n// //         \"selected\": false\n// //       };\n// //     });\n// //     return lasso;\n// //   };\n\n// //   // Return possible items\n// //   lasso.possibleItems = function () {\n// //     return items.filter(function () {\n// //       return this.__lasso.possible;\n// //     });\n// //   }\n\n// //   // Return selected items\n// //   lasso.selectedItems = function () {\n// //     return items.filter(function () {\n// //       return this.__lasso.selected;\n// //     });\n// //   }\n\n// //   // Return not possible items\n// //   lasso.notPossibleItems = function () {\n// //     return items.filter(function () {\n// //       return !this.__lasso.possible;\n// //     });\n// //   }\n\n// //   // Return not selected items\n// //   lasso.notSelectedItems = function () {\n// //     return items.filter(function () {\n// //       return !this.__lasso.selected;\n// //     });\n// //   }\n\n// //   // Distance required before path auto closes loop\n// //   lasso.closePathDistance = function (_) {\n// //     if (!arguments.length) return closePathDistance;\n// //     closePathDistance = _;\n// //     return lasso;\n// //   };\n\n// //   // Option to loop select or not\n// //   lasso.closePathSelect = function (_) {\n// //     if (!arguments.length) return closePathSelect;\n// //     closePathSelect = _ === true ? true : false;\n// //     return lasso;\n// //   };\n\n// //   // Not sure what this is for\n// //   lasso.isPathClosed = function (_) {\n// //     if (!arguments.length) return isPathClosed;\n// //     isPathClosed = _ === true ? true : false;\n// //     return lasso;\n// //   };\n\n// //   // Option to select on hover or not\n// //   lasso.hoverSelect = function (_) {\n// //     if (!arguments.length) return hoverSelect;\n// //     hoverSelect = _ === true ? true : false;\n// //     return lasso;\n// //   };\n\n// //   // Events\n// //   lasso.on = function (type, _) {\n// //     if (!arguments.length) return on;\n// //     if (arguments.length === 1) return on[type];\n// //     var types = [\"start\", \"draw\", \"end\"];\n// //     if (types.indexOf(type) > -1) {\n// //       on[type] = _;\n// //     }\n// //     return lasso;\n// //   };\n\n// //   // Area where lasso can be triggered from\n// //   lasso.targetArea = function (_) {\n// //     if (!arguments.length) return targetArea;\n// //     targetArea = _;\n// //     return lasso;\n// //   }\n\n// //   return lasso;\n// // };","map":{"version":3,"names":["d3","trackPointer","e","start","move","out","end","tracker","id","pointerId","target","point","pointer","setPointerCapture","select","on","sourceEvent","releasePointerCapture","prev","lasso","dispatch","selection","node","polygon","preventDefault","p","length","call","push","type","_","arguments"],"sources":["/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/src/d3-lasso-adapted.js"],"sourcesContent":["import * as d3 from 'd3'\n// import { trackPointer } from \"@fil/pointer-events\"\n\nfunction trackPointer(e, { start, move, out, end }) { //from https://observablehq.com/@fil/pointer-events#trackPointer\n  const tracker = {},\n    id = (tracker.id = e.pointerId),\n    target = e.target;\n  tracker.point = d3.pointer(e, target);\n  target.setPointerCapture(id);\n\n  d3.select(target)\n    .on(`pointerup.${id} pointercancel.${id} lostpointercapture.${id}`, (e) => {\n      if (e.pointerId !== id) return;\n      tracker.sourceEvent = e;\n      d3.select(target).on(`.${id}`, null);\n      target.releasePointerCapture(id);\n      end && end(tracker);\n    })\n    .on(`pointermove.${id}`, (e) => {\n      if (e.pointerId !== id) return;\n      tracker.sourceEvent = e;\n      tracker.prev = tracker.point;\n      tracker.point = d3.pointer(e, target);\n      move && move(tracker);\n    })\n    .on(`pointerout.${id}`, (e) => {\n      if (e.pointerId !== id) return;\n      tracker.sourceEvent = e;\n      tracker.point = null;\n      out && out(tracker);\n    });\n\n  start && start(tracker);\n}\n\nexport default function lasso() { // from https://observablehq.com/@fil/lasso-selection\n  const dispatch = d3.dispatch(\"start\", \"lasso\", \"end\");\n  const lasso = function (selection) {\n    const node = selection.node();\n    const polygon = [];\n\n    selection\n      .on(\"touchmove\", e => e.preventDefault()) // prevent scrolling\n      .on(\"pointerdown\", e => {\n        trackPointer(e, {\n          start: p => {\n            polygon.length = 0;\n            dispatch.call(\"start\", node, polygon);\n          },\n          move: p => {\n            polygon.push(p.point);\n            dispatch.call(\"lasso\", node, polygon);\n          },\n          end: p => {\n            dispatch.call(\"end\", node, polygon);\n          }\n        });\n      });\n  };\n  lasso.on = function (type, _) {\n    return _ ? (dispatch.on(...arguments), lasso) : dispatch.on(...arguments);\n  };\n\n  return lasso;\n}\n\n// import * as d3 from 'd3'\n// //version2 https://github.com/skokenes/D3-Lasso-Plugin/blob/master/lasso.js\n// d3.lasso = function () {\n\n//   var items = null,\n//     closePathDistance = 75,\n//     closePathSelect = true,\n//     isPathClosed = false,\n//     hoverSelect = true,\n//     points = [],\n//     area = null,\n//     on = { start: function () { }, draw: function () { }, end: function () { } };\n\n//   function lasso() {\n//     // the element where the lasso was called\n//     var _this = d3.select(this[0][0]);\n\n//     // add a new group for the lasso\n//     var g = _this.append(\"g\")\n//       .attr(\"class\", \"lasso\");\n\n//     // add the drawn path for the lasso\n//     var dyn_path = g.append(\"path\")\n//       .attr(\"class\", \"drawn\");\n\n//     // add a path used for calculations\n//     var calc_path = g.append(\"path\")\n//       .attr(\"display\", \"none\");\n\n//     // add a closed path\n//     var close_path = g.append(\"path\")\n//       .attr(\"class\", \"loop_close\");\n\n//     // add a close path used for calculations\n//     var calc_close_path = g.append(\"path\")\n//       .attr(\"display\", \"none\");\n\n//     // add an origin node\n//     var origin_node = g.append(\"circle\")\n//       .attr(\"class\", \"origin\");\n\n//     // The lasso path for calculations\n//     var path;\n\n//     // The transformed lasso path for rendering\n//     var tpath;\n\n//     // The lasso origin for calculations\n//     var origin;\n\n//     // The transformed lasso origin for rendering\n//     var torigin;\n\n//     // The last known point on the lasso during drag - needed for evaluating edges\n//     var last_known_point;\n\n//     // The starting point for evaluating the path\n//     var path_length_start;\n\n//     // Apply drag behaviors\n//     var drag = d3.behavior.drag()\n//       .on(\"dragstart\", dragstart)\n//       .on(\"drag\", dragmove)\n//       .on(\"dragend\", dragend);\n\n//     // Call drag\n//     area.call(drag);\n\n//     function dragstart() {\n//       // Initialize paths\n//       path = \"\";\n//       tpath = \"\";\n//       dyn_path.attr(\"d\", null);\n//       close_path.attr(\"d\", null);\n\n//       // Set path length start\n//       path_length_start = 0;\n\n//       // Set every item to have a false selection and reset their center point and counters\n//       items[0].forEach(function (d) {\n//         d.hoverSelected = false;\n//         d.loopSelected = false;\n//         var box = d.getBoundingClientRect();\n//         d.lassoPoint = {\n//           cx: Math.round(box.left + box.width / 2),\n//           cy: Math.round(box.top + box.height / 2),\n//           edges: { top: 0, right: 0, bottom: 0, left: 0 },\n//           close_edges: { left: 0, right: 0 }\n//         };\n\n\n//       });\n\n//       // if hover is on, add hover function\n//       if (hoverSelect === true) {\n//         items.on(\"mouseover.lasso\", function () {\n//           // if hovered, change lasso selection attribute to true\n//           d3.select(this)[0][0].hoverSelected = true;\n//         });\n//       }\n\n//       // Run user defined start function\n//       on.start();\n//     }\n\n//     function dragmove() {\n//       // Get mouse position within body, used for calculations\n//       var x = d3.event.sourceEvent.clientX;\n//       var y = d3.event.sourceEvent.clientY;\n//       // Get mouse position within drawing area, used for rendering\n//       var tx = d3.mouse(this)[0];\n//       var ty = d3.mouse(this)[1];\n\n//       // Initialize the path or add the latest point to it\n//       if (path === \"\") {\n//         path = path + \"M \" + x + \" \" + y;\n//         tpath = tpath + \"M \" + tx + \" \" + ty;\n//         origin = [x, y];\n//         torigin = [tx, ty];\n//         // Draw origin node\n//         origin_node\n//           .attr(\"cx\", tx)\n//           .attr(\"cy\", ty)\n//           .attr(\"r\", 7)\n//           .attr(\"display\", null);\n//       }\n//       else {\n//         path = path + \" L \" + x + \" \" + y;\n//         tpath = tpath + \" L \" + tx + \" \" + ty;\n//       }\n\n//       // Reset closed edges counter\n//       items[0].forEach(function (d) {\n//         d.lassoPoint.close_edges = { left: 0, right: 0 };\n//       });\n\n//       // Calculate the current distance from the lasso origin\n//       var distance = Math.sqrt(Math.pow(x - origin[0], 2) + Math.pow(y - origin[1], 2));\n\n//       // Set the closed path line\n//       var close_draw_path = \"M \" + tx + \" \" + ty + \" L \" + torigin[0] + \" \" + torigin[1];\n\n//       // Set the calc closed path line\n//       var calc_close_draw_path = \"M \" + x + \" \" + y + \" L \" + origin[0] + \" \" + origin[1];\n\n//       // Draw the lines\n//       dyn_path.attr(\"d\", tpath);\n\n//       // path for calcs\n//       calc_path.attr(\"d\", path);\n\n//       calc_close_path.attr(\"d\", calc_close_draw_path);\n\n//       // Check if the path is closed\n//       isPathClosed = distance <= closePathDistance ? true : false;\n\n//       // If within the closed path distance parameter, show the closed path. otherwise, hide it\n//       if (isPathClosed) {\n//         close_path.attr(\"display\", null);\n//       }\n//       else {\n//         close_path.attr(\"display\", \"none\");\n//       }\n\n\n//       // Get path length\n//       var path_node = calc_path.node();\n//       var path_length_end = path_node.getTotalLength();\n//       // Get the ending point of the path\n//       var last_pos = path_node.getPointAtLength(path_length_start - 1);\n\n//       // Iterate through each point on the path\n//       for (var i = path_length_start; i <= path_length_end; i++) {\n//         // Get the current coordinates on the path\n//         var cur_pos = path_node.getPointAtLength(i);\n//         var cur_pos_obj = {\n//           x: Math.round(cur_pos.x * 100) / 100,\n//           y: Math.round(cur_pos.y * 100) / 100,\n//         };\n//         // Get the prior coordinates on the path\n//         var prior_pos = path_node.getPointAtLength(i - 1);\n//         var prior_pos_obj = {\n//           x: Math.round(prior_pos.x * 100) / 100,\n//           y: Math.round(prior_pos.y * 100) / 100,\n//         };\n\n//         // Iterate through each item\n//         items[0].filter(function (d) {\n//           var a;\n//           // If we are on the same y position as the item and we weren't on this y before,\n//           // mark as the last known point. Return false - we don't need to count an edge yet\n//           if (d.lassoPoint.cy === cur_pos_obj.y && d.lassoPoint.cy != prior_pos_obj.y) {\n//             last_known_point = {\n//               x: prior_pos_obj.x,\n//               y: prior_pos_obj.y\n//             };\n//             a = false;\n//           }\n//           // If we are on the same y position as the item and we were on this y before,\n//           // return false - we don't need to count an edge yet\n//           else if (d.lassoPoint.cy === cur_pos_obj.y && d.lassoPoint.cy === prior_pos_obj.y) {\n//             a = false;\n//           }\n//           // If we are not on the same y position as the item but we were previously,\n//           // determine if we passed by the item or came up to it and turned around.\n//           // Return true if we passed it so that we can evaluate for an edge\n//           else if (d.lassoPoint.cy != cur_pos_obj.y && d.lassoPoint.cy === prior_pos_obj.y) {\n//             a = sign(d.lassoPoint.cy - cur_pos_obj.y) != sign(d.lassoPoint.cy - last_known_point.y);\n//           }\n//           // Else, mark a last known point and check for a crossing.\n//           // If we crossed, we need to evaluate for edges\n//           else {\n//             last_known_point = {\n//               x: prior_pos_obj.x,\n//               y: prior_pos_obj.y\n//             };\n//             a = sign(d.lassoPoint.cy - cur_pos_obj.y) != sign(d.lassoPoint.cy - prior_pos_obj.y);\n//           }\n//           return a;\n//         }).forEach(function (d) {\n//           // Iterate through each object and add an edge to the left or right\n//           if (cur_pos_obj.x > d.lassoPoint.cx) {\n//             d.lassoPoint.edges.right = d.lassoPoint.edges.right + 1;\n//           }\n//           if (cur_pos_obj.x < d.lassoPoint.cx) {\n//             d.lassoPoint.edges.left = d.lassoPoint.edges.left + 1;\n//           }\n//         });\n//       }\n\n//       // If the path is closed and close select is set to true, draw the closed paths and count edges\n//       if (isPathClosed === true && closePathSelect === true) {\n//         close_path.attr(\"d\", close_draw_path);\n//         var close_path_node = calc_close_path.node();\n//         var close_path_length = close_path_node.getTotalLength();\n//         var close_path_edges = { left: 0, right: 0 };\n//         for (var i = 0; i <= close_path_length; i++) {\n//           var cur_pos = close_path_node.getPointAtLength(i);\n//           var prior_pos = close_path_node.getPointAtLength(i - 1);\n\n//           items[0].filter(function (d) { return d.lassoPoint.cy == Math.round(cur_pos.y); }).forEach(function (d) {\n//             if (Math.round(cur_pos.y) != Math.round(prior_pos.y) && Math.round(cur_pos.x) > d.lassoPoint.cx) {\n//               d.lassoPoint.close_edges.right = 1;\n//             }\n//             if (Math.round(cur_pos.y) != Math.round(prior_pos.y) && Math.round(cur_pos.x) < d.lassoPoint.cx) {\n//               d.lassoPoint.close_edges.left = 1;\n//             }\n//           });\n\n//         }\n\n//         // Check and see if the points have at least one edge to the left, and an odd # of edges to the right. If so, mark as selected.\n//         items[0].forEach(function (a) {\n//           if ((a.lassoPoint.edges.left + a.lassoPoint.close_edges.left) > 0 && (a.lassoPoint.edges.right + a.lassoPoint.close_edges.right) % 2 == 1) {\n//             a.loopSelected = true;\n//           }\n//           else {\n//             a.loopSelected = false;\n//           }\n//         });\n//       }\n//       else {\n//         items[0].forEach(function (d) {\n//           d.loopSelected = false;\n//         });\n//       }\n\n//       // Tag possible items\n//       d3.selectAll(items[0].filter(function (d) { return (d.loopSelected && isPathClosed) || d.hoverSelected; }))\n//         .each(function (d) { d.possible = true; });\n\n//       d3.selectAll(items[0].filter(function (d) { return !((d.loopSelected && isPathClosed) || d.hoverSelected); }))\n//         .each(function (d) { d.possible = false; });\n\n//       on.draw();\n\n//       // Continue drawing path from where it left off\n//       path_length_start = path_length_end + 1;\n//     }\n\n//     function dragend() {\n//       // Remove mouseover tagging function\n//       items.on(\"mouseover.lasso\", null);\n\n//       // Tag selected items\n//       items.filter(function (d) { return d.possible === true; })\n//         .each(function (d) { d.selected = true; });\n\n//       items.filter(function (d) { return d.possible === false; })\n//         .each(function (d) { d.selected = false; });\n\n//       // Reset possible items\n//       items\n//         .each(function (d) { d.possible = false; });\n\n//       // Clear lasso\n//       dyn_path.attr(\"d\", null);\n//       close_path.attr(\"d\", null);\n//       origin_node.attr(\"display\", \"none\");\n\n//       // Run user defined end function\n//       on.end();\n\n//     }\n//   }\n\n//   lasso.items = function (_) {\n\n//     if (!arguments.length) return items;\n//     items = _;\n//     items[0].forEach(function (d) {\n//       var item = d3.select(d);\n//       if (typeof item.datum() === 'undefined') {\n//         item.datum({ possible: false, selected: false });\n//       }\n//       else {\n//         //item.attr(\"d\",function(e) {e.possible = false; e.selected = false; return e;});\n//         var e = item.datum();\n//         e.possible = false;\n//         e.selected = false;\n//         item.datum(e);\n//       }\n//     });\n//     return lasso;\n//   };\n\n//   lasso.closePathDistance = function (_) {\n//     if (!arguments.length) return closePathDistance;\n//     closePathDistance = _;\n//     return lasso;\n//   };\n\n//   lasso.closePathSelect = function (_) {\n//     if (!arguments.length) return closePathSelect;\n//     closePathSelect = _ === true ? true : false;\n//     return lasso;\n//   };\n\n//   lasso.isPathClosed = function (_) {\n//     if (!arguments.length) return isPathClosed;\n//     isPathClosed = _ === true ? true : false;\n//     return lasso;\n//   };\n\n//   lasso.hoverSelect = function (_) {\n//     if (!arguments.length) return hoverSelect;\n//     hoverSelect = _ === true ? true : false;\n//     return lasso;\n//   };\n\n//   lasso.on = function (type, _) {\n//     if (!arguments.length) return on;\n//     if (arguments.length === 1) return on[type];\n//     var types = [\"start\", \"draw\", \"end\"];\n//     if (types.indexOf(type) > -1) {\n//       on[type] = _;\n//     }\n//     return lasso;\n//   };\n\n//   lasso.area = function (_) {\n//     if (!arguments.length) return area;\n//     area = _;\n//     return lasso;\n//   };\n\n//   function sign(x) {\n//     return x ? x < 0 ? -1 : 1 : 0;\n//   }\n\n\n//   return lasso;\n\n// };\n// //---version1 https://github.com/skokenes/d3-lasso/blob/master/src/lasso.js\n// // import * as selection from \"d3-selection\";\n// // import * as d3 from \"d3\"\n// // import * as drag from \"d3-drag\";\n// // import classifyPoint from \"robust-point-in-polygon\";\n\n// // export default function () {\n\n// //   var items = [],\n// //     closePathDistance = 75,\n// //     closePathSelect = true,\n// //     isPathClosed = false,\n// //     hoverSelect = true,\n// //     targetArea,\n// //     on = { start: function () { }, draw: function () { }, end: function () { } };\n\n// //   // Function to execute on call\n// //   function lasso(_this) {\n\n// //     // add a new group for the lasso\n// //     var g = _this.append(\"g\")\n// //       .attr(\"class\", \"lasso\");\n\n// //     // add the drawn path for the lasso\n// //     var dyn_path = g.append(\"path\")\n// //       .attr(\"class\", \"drawn\");\n\n// //     // add a closed path\n// //     var close_path = g.append(\"path\")\n// //       .attr(\"class\", \"loop_close\");\n\n// //     // add an origin node\n// //     var origin_node = g.append(\"circle\")\n// //       .attr(\"class\", \"origin\");\n\n// //     // The transformed lasso path for rendering\n// //     var tpath;\n\n// //     // The lasso origin for calculations\n// //     var origin;\n\n// //     // The transformed lasso origin for rendering\n// //     var torigin;\n\n// //     // Store off coordinates drawn\n// //     var drawnCoords;\n\n// //     // Apply drag behaviors\n// //     var dragAction = drag.drag()\n// //       .on(\"start\", dragstart)\n// //       .on(\"drag\", dragmove)\n// //       .on(\"end\", dragend);\n\n// //     // Call drag\n// //     targetArea.call(dragAction);\n\n// //     function dragstart() {\n// //       // Init coordinates\n// //       drawnCoords = [];\n\n// //       // Initialize paths\n// //       tpath = \"\";\n// //       dyn_path.attr(\"d\", null);\n// //       close_path.attr(\"d\", null);\n\n// //       // Set every item to have a false selection and reset their center point and counters\n// //       items.nodes().forEach(function (e) {\n// //         e.__lasso.possible = false;\n// //         e.__lasso.selected = false;\n// //         e.__lasso.hoverSelect = false;\n// //         e.__lasso.loopSelect = false;\n\n// //         var box = e.getBoundingClientRect();\n// //         e.__lasso.lassoPoint = [Math.round(box.left + box.width / 2), Math.round(box.top + box.height / 2)];\n// //       });\n\n// //       // if hover is on, add hover function\n// //       if (hoverSelect) {\n// //         items.on(\"mouseover.lasso\", function () {\n// //           // if hovered, change lasso selection attribute to true\n// //           this.__lasso.hoverSelect = true;\n// //         });\n// //       }\n\n// //       // Run user defined start function\n// //       on.start();\n// //     }\n\n// //     function dragmove(event) {\n// //       // Get mouse position within body, used for calculations\n// //       var x, y;\n// //       if (event.type === \"touchmove\") {\n// //         x = event.touches[0].clientX;\n// //         y = event.touches[0].clientY;\n// //       } else {\n// //         x = event.clientX;\n// //         y = event.clientY;\n// //       }\n\n// //       // Get mouse position within drawing area, used for rendering\n// //       var tx = d3.pointer(event, this)[0];\n// //       var ty = d3.pointer(event, this)[1];\n\n// //       // Initialize the path or add the latest point to it\n// //       if (tpath === \"\") {\n// //         tpath = tpath + \"M \" + tx + \" \" + ty;\n// //         origin = [x, y];\n// //         torigin = [tx, ty];\n// //         // Draw origin node\n// //         origin_node\n// //           .attr(\"cx\", tx)\n// //           .attr(\"cy\", ty)\n// //           .attr(\"r\", 7)\n// //           .attr(\"display\", null);\n// //       } else {\n// //         tpath = tpath + \" L \" + tx + \" \" + ty;\n// //       }\n\n// //       drawnCoords.push([x, y]);\n\n// //       // Calculate the current distance from the lasso origin\n// //       var distance = Math.sqrt(Math.pow(x - origin[0], 2) + Math.pow(y - origin[1], 2));\n\n// //       // Set the closed path line\n// //       var close_draw_path = \"M \" + tx + \" \" + ty + \" L \" + torigin[0] + \" \" + torigin[1];\n\n// //       // Draw the lines\n// //       dyn_path.attr(\"d\", tpath);\n\n// //       close_path.attr(\"d\", close_draw_path);\n\n// //       // Check if the path is closed\n// //       isPathClosed = distance <= closePathDistance ? true : false;\n\n// //       // If within the closed path distance parameter, show the closed path. otherwise, hide it\n// //       if (isPathClosed && closePathSelect) {\n// //         close_path.attr(\"display\", null);\n// //       } else {\n// //         close_path.attr(\"display\", \"none\");\n// //       }\n\n// //       items.nodes().forEach(function (n) {\n// //         n.__lasso.loopSelect = isPathClosed && closePathSelect ? classifyPoint(drawnCoords, n.__lasso.lassoPoint) < 1 : false;\n// //         n.__lasso.possible = n.__lasso.hoverSelect || n.__lasso.loopSelect;\n// //       });\n\n// //       on.draw();\n// //     }\n\n// //     // function dragmove() {\n// //     //     // Get mouse position within body, used for calculations\n// //     //     var x,y;\n// //     //     if(selection.event.sourceEvent.type === \"touchmove\") {\n// //     //         x = selection.event.sourceEvent.touches[0].clientX;\n// //     //         y = selection.event.sourceEvent.touches[0].clientY;\n// //     //     }\n// //     //     else {\n// //     //         x = selection.event.sourceEvent.clientX;\n// //     //         y = selection.event.sourceEvent.clientY;\n// //     //     }\n\n\n// //     //     // Get mouse position within drawing area, used for rendering\n// //     //     var tx = selection.mouse(this)[0];\n// //     //     var ty = selection.mouse(this)[1];\n\n// //     //     // Initialize the path or add the latest point to it\n// //     //     if (tpath===\"\") {\n// //     //         tpath = tpath + \"M \" + tx + \" \" + ty;\n// //     //         origin = [x,y];\n// //     //         torigin = [tx,ty];\n// //     //         // Draw origin node\n// //     //         origin_node\n// //     //             .attr(\"cx\",tx)\n// //     //             .attr(\"cy\",ty)\n// //     //             .attr(\"r\",7)\n// //     //             .attr(\"display\",null);\n// //     //     }\n// //     //     else {\n// //     //         tpath = tpath + \" L \" + tx + \" \" + ty;\n// //     //     }\n\n// //     //     drawnCoords.push([x,y]);\n\n// //     //     // Calculate the current distance from the lasso origin\n// //     //     var distance = Math.sqrt(Math.pow(x-origin[0],2)+Math.pow(y-origin[1],2));\n\n// //     //     // Set the closed path line\n// //     //     var close_draw_path = \"M \" + tx + \" \" + ty + \" L \" + torigin[0] + \" \" + torigin[1];\n\n// //     //     // Draw the lines\n// //     //     dyn_path.attr(\"d\",tpath);\n\n// //     //     close_path.attr(\"d\",close_draw_path);\n\n// //     //     // Check if the path is closed\n// //     //     isPathClosed = distance<=closePathDistance ? true : false;\n\n// //     //     // If within the closed path distance parameter, show the closed path. otherwise, hide it\n// //     //     if(isPathClosed && closePathSelect) {\n// //     //         close_path.attr(\"display\",null);\n// //     //     }\n// //     //     else {\n// //     //         close_path.attr(\"display\",\"none\");\n// //     //     }\n\n// //     //     items.nodes().forEach(function(n) {\n// //     //         n.__lasso.loopSelect = (isPathClosed && closePathSelect) ? (classifyPoint(drawnCoords,n.__lasso.lassoPoint) < 1) : false; \n// //     //         n.__lasso.possible = n.__lasso.hoverSelect || n.__lasso.loopSelect; \n// //     //     });\n\n// //     //     on.draw();\n// //     // }\n\n// //     function dragend() {\n// //       // Remove mouseover tagging function\n// //       items.on(\"mouseover.lasso\", null);\n\n// //       items.nodes().forEach(function (n) {\n// //         n.__lasso.selected = n.__lasso.possible;\n// //         n.__lasso.possible = false;\n// //       });\n\n// //       // Clear lasso\n// //       dyn_path.attr(\"d\", null);\n// //       close_path.attr(\"d\", null);\n// //       origin_node.attr(\"display\", \"none\");\n\n// //       // Run user defined end function\n// //       on.end();\n// //     }\n// //   }\n\n// //   // Set or get list of items for lasso to select\n// //   lasso.items = function (_) {\n// //     if (!arguments.length) return items;\n// //     items = _;\n// //     var nodes = items.nodes();\n// //     nodes.forEach(function (n) {\n// //       n.__lasso = {\n// //         \"possible\": false,\n// //         \"selected\": false\n// //       };\n// //     });\n// //     return lasso;\n// //   };\n\n// //   // Return possible items\n// //   lasso.possibleItems = function () {\n// //     return items.filter(function () {\n// //       return this.__lasso.possible;\n// //     });\n// //   }\n\n// //   // Return selected items\n// //   lasso.selectedItems = function () {\n// //     return items.filter(function () {\n// //       return this.__lasso.selected;\n// //     });\n// //   }\n\n// //   // Return not possible items\n// //   lasso.notPossibleItems = function () {\n// //     return items.filter(function () {\n// //       return !this.__lasso.possible;\n// //     });\n// //   }\n\n// //   // Return not selected items\n// //   lasso.notSelectedItems = function () {\n// //     return items.filter(function () {\n// //       return !this.__lasso.selected;\n// //     });\n// //   }\n\n// //   // Distance required before path auto closes loop\n// //   lasso.closePathDistance = function (_) {\n// //     if (!arguments.length) return closePathDistance;\n// //     closePathDistance = _;\n// //     return lasso;\n// //   };\n\n// //   // Option to loop select or not\n// //   lasso.closePathSelect = function (_) {\n// //     if (!arguments.length) return closePathSelect;\n// //     closePathSelect = _ === true ? true : false;\n// //     return lasso;\n// //   };\n\n// //   // Not sure what this is for\n// //   lasso.isPathClosed = function (_) {\n// //     if (!arguments.length) return isPathClosed;\n// //     isPathClosed = _ === true ? true : false;\n// //     return lasso;\n// //   };\n\n// //   // Option to select on hover or not\n// //   lasso.hoverSelect = function (_) {\n// //     if (!arguments.length) return hoverSelect;\n// //     hoverSelect = _ === true ? true : false;\n// //     return lasso;\n// //   };\n\n// //   // Events\n// //   lasso.on = function (type, _) {\n// //     if (!arguments.length) return on;\n// //     if (arguments.length === 1) return on[type];\n// //     var types = [\"start\", \"draw\", \"end\"];\n// //     if (types.indexOf(type) > -1) {\n// //       on[type] = _;\n// //     }\n// //     return lasso;\n// //   };\n\n// //   // Area where lasso can be triggered from\n// //   lasso.targetArea = function (_) {\n// //     if (!arguments.length) return targetArea;\n// //     targetArea = _;\n// //     return lasso;\n// //   }\n\n\n\n// //   return lasso;\n// // };"],"mappings":"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;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}