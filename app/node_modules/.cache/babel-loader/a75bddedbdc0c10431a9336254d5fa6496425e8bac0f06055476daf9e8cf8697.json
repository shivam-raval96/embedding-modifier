{"ast":null,"code":"import _classCallCheck from \"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Pass } from './Pass.js';\nvar MaskPass = /*#__PURE__*/function (_Pass) {\n  _inherits(MaskPass, _Pass);\n  var _super = _createSuper(MaskPass);\n  function MaskPass(scene, camera) {\n    var _this;\n    _classCallCheck(this, MaskPass);\n    _this = _super.call(this);\n    _this.scene = scene;\n    _this.camera = camera;\n    _this.clear = true;\n    _this.needsSwap = false;\n    _this.inverse = false;\n    return _this;\n  }\n  _createClass(MaskPass, [{\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {\n      var context = renderer.getContext();\n      var state = renderer.state;\n\n      // don't update color or depth\n\n      state.buffers.color.setMask(false);\n      state.buffers.depth.setMask(false);\n\n      // lock buffers\n\n      state.buffers.color.setLocked(true);\n      state.buffers.depth.setLocked(true);\n\n      // set up stencil\n\n      var writeValue, clearValue;\n      if (this.inverse) {\n        writeValue = 0;\n        clearValue = 1;\n      } else {\n        writeValue = 1;\n        clearValue = 0;\n      }\n      state.buffers.stencil.setTest(true);\n      state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n      state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);\n      state.buffers.stencil.setClear(clearValue);\n      state.buffers.stencil.setLocked(true);\n\n      // draw into the stencil buffer\n\n      renderer.setRenderTarget(readBuffer);\n      if (this.clear) renderer.clear();\n      renderer.render(this.scene, this.camera);\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      renderer.render(this.scene, this.camera);\n\n      // unlock color and depth buffer and make them writable for subsequent rendering/clearing\n\n      state.buffers.color.setLocked(false);\n      state.buffers.depth.setLocked(false);\n      state.buffers.color.setMask(true);\n      state.buffers.depth.setMask(true);\n\n      // only render where stencil is set to 1\n\n      state.buffers.stencil.setLocked(false);\n      state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1\n      state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n      state.buffers.stencil.setLocked(true);\n    }\n  }]);\n  return MaskPass;\n}(Pass);\nvar ClearMaskPass = /*#__PURE__*/function (_Pass2) {\n  _inherits(ClearMaskPass, _Pass2);\n  var _super2 = _createSuper(ClearMaskPass);\n  function ClearMaskPass() {\n    var _this2;\n    _classCallCheck(this, ClearMaskPass);\n    _this2 = _super2.call(this);\n    _this2.needsSwap = false;\n    return _this2;\n  }\n  _createClass(ClearMaskPass, [{\n    key: \"render\",\n    value: function render(renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */) {\n      renderer.state.buffers.stencil.setLocked(false);\n      renderer.state.buffers.stencil.setTest(false);\n    }\n  }]);\n  return ClearMaskPass;\n}(Pass);\nexport { MaskPass, ClearMaskPass };","map":{"version":3,"names":["Pass","MaskPass","_Pass","_inherits","_super","_createSuper","scene","camera","_this","_classCallCheck","call","clear","needsSwap","inverse","_createClass","key","value","render","renderer","writeBuffer","readBuffer","context","getContext","state","buffers","color","setMask","depth","setLocked","writeValue","clearValue","stencil","setTest","setOp","REPLACE","setFunc","ALWAYS","setClear","setRenderTarget","EQUAL","KEEP","ClearMaskPass","_Pass2","_super2","_this2"],"sources":["/Users/Shivam/Library/CloudStorage/GoogleDrive-sraval@g.harvard.edu/My Drive/Github/embedding-modifier/app/node_modules/three/examples/jsm/postprocessing/MaskPass.js"],"sourcesContent":["import { Pass } from './Pass.js';\n\nclass MaskPass extends Pass {\n\n\tconstructor( scene, camera ) {\n\n\t\tsuper();\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.clear = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis.inverse = false;\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tconst context = renderer.getContext();\n\t\tconst state = renderer.state;\n\n\t\t// don't update color or depth\n\n\t\tstate.buffers.color.setMask( false );\n\t\tstate.buffers.depth.setMask( false );\n\n\t\t// lock buffers\n\n\t\tstate.buffers.color.setLocked( true );\n\t\tstate.buffers.depth.setLocked( true );\n\n\t\t// set up stencil\n\n\t\tlet writeValue, clearValue;\n\n\t\tif ( this.inverse ) {\n\n\t\t\twriteValue = 0;\n\t\t\tclearValue = 1;\n\n\t\t} else {\n\n\t\t\twriteValue = 1;\n\t\t\tclearValue = 0;\n\n\t\t}\n\n\t\tstate.buffers.stencil.setTest( true );\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\n\t\tstate.buffers.stencil.setClear( clearValue );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t\t// draw into the stencil buffer\n\n\t\trenderer.setRenderTarget( readBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\trenderer.setRenderTarget( writeBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\t// unlock color and depth buffer and make them writable for subsequent rendering/clearing\n\n\t\tstate.buffers.color.setLocked( false );\n\t\tstate.buffers.depth.setLocked( false );\n\n\t\tstate.buffers.color.setMask( true );\n\t\tstate.buffers.depth.setMask( true );\n\n\t\t// only render where stencil is set to 1\n\n\t\tstate.buffers.stencil.setLocked( false );\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t}\n\n}\n\nclass ClearMaskPass extends Pass {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.needsSwap = false;\n\n\t}\n\n\trender( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\trenderer.state.buffers.stencil.setLocked( false );\n\t\trenderer.state.buffers.stencil.setTest( false );\n\n\t}\n\n}\n\nexport { MaskPass, ClearMaskPass };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}